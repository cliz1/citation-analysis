nathanielclizbe@MacBookAir citation-analysis % python3 ref_analysis.py
Loaded 98 paper titles from google sheets.
Found 936 PDFs in Zotero storage
94 PDFs match titles in papers_list.txt
1. Arora, S., Lund, C., Motwani, R., Sudan, M., Szegedy, M.: Proof veriﬁcation and the hardness of approximation problems. J. ACM 45(3), 501–555 (1998)
2. Arora, S., Safra, S.: Probabilistic checking of proofs: a new characterization of NP. J. ACM 45(1), 70–122 (1998). Preliminary version in FOCS 1992
3. Babai, L.: Trading group theory for randomness. In: Proceedings of the 17th Annual ACM Symposium on Theory of Computing, STOC 1985, (1985)
4. Babai, L., Fortnow, L., Levin, L.A., Szegedy, M.: Checking computations in poly- logarithmic time. In: Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC 1991,  (1991)
5. Babai, L., Moran, S.: Arthur-merlin games: a randomized proof system, and a hierarchy of complexity classes. J. Comput. Syst. Sci. 36(2), 254–276 (1988)
6. Bellare, M., Goldreich, O., Goldwasser, S.: Randomness in interactive proofs. In: Proceedings of the 31st Annual Symposium on Foundations of Computer Science, FOCS 1990,  (1990)
13. Ben-Sasson, E., Goldberg, L., Kopparty, S., Saraf, S.: DEEP-FRI: sampling outside the box improves soundness. In: Proceedings of the 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, pp. 5:1–5:32 (2020)
14. Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.: Short PCPs veriﬁable in polylogarithmic time. In: Proceedings of the 20th Annual IEEE Con- ference on Computational Complexity, CCC 2005,  (2005) 92 G. Arnon et al.
15. Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.P.: Robust PCPs of proximity, shorter PCPs, and applications to coding. SIAM J. Comput. 36(4), 889–974 (2006)
16. Ben-Sasson, E., Sudan, M.: Short PCPs with polylog query complexity. SIAM J. Comput. 38(2), 551–607 (2008)
17. Benarroch, D., et al.: Proposal: commit-and-prove zero-knowledge proof sys- tems and extensions (2021). https://docs.zkproof.org/pages/standards/accepted- workshop4/proposal-commit.pdf
21. Bordage, S., Nardi, J.: Interactive oracle proofs of proximity to algebraic geometry codes. arXiv cs/2011.04295 (2021)
27. Condon, A., Feigenbaum, J., Lund, C., Shor, P.W.: Probabilistically checkable debate systems and nonapproximability of PSPACE-hard functions. Chicago J. Theor. Comput. Sci. 1995 (1995)
28. Condon, A., Feigenbaum, J., Lund, C., Shor, P.W.: Random debaters and the hardness of approximating stochastic functions. SIAM J. Comput. 26(2), 369–400 (1997)
30. Dinur, I.: The PCP theorem by gap ampliﬁcation. J. ACM 54(3), 12 (2007)
31. Dinur, I., Reingold, O.: Assignment testers: towards a combinatorial proof of the PCP theorem. In: Proceedings of the 45th Annual IEEE Symposium on Founda- tions of Computer Science, FOCS 2004,  (2004) A PCP Theorem for Interactive Proofs and Applications 93
34. Drucker, A.: An improved exponential-time approximation algorithm for fully- alternating games against nature. In: Proceedings of the 61st Annual IEEE Sym- posium on Foundations of Computer Science, FOCS 2020,  (2020)
36. Feige, U., Goldwasser, S., Lov´asz, L., Safra, S., Szegedy, M.: Interactive proofs and the hardness of approximating cliques. J. ACM 43(2), 268–292 (1996). Preliminary version in FOCS 1991
37. F¨urer, M., Goldreich, O., Mansour, Y., Sipser, M., Zachos, S.: On completeness and soundness in interactive proof systems. Adv. Comput. Res. 5, 429–442 (1989)
38. Goldreich, O., Micali, S., Wigderson, A.: Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. J. ACM 38(3), 691–729 (1991). Preliminary version appeared in FOCS 1986
39. Goldreich, O., Vadhan, S., Wigderson, A.: On interactive proofs with a laconic prover. Comput. Complex. 11(1/2), 1–53 (2002)
40. Goldwasser, S., Micali, S., Rackoﬀ, C.: The knowledge complexity of interac- tive proof systems. SIAM J. Comput. 18(1), 186–208 (1989). Preliminary version appeared in STOC 1985
41. Goldwasser, S., Sipser, M.: Private coins versus public coins in interactive proof systems. In: Proceedings of the 18th Annual ACM Symposium on Theory of Com- puting, STOC 1986,  (1986)
42. Guruswami, V., Umans, C., Vadhan, S.P.: Unbalanced expanders and randomness extractors from Parvaresh-Vardy codes. J. ACM 56(4), 20:1–20:34 (2009)
43. Haviv, I., Regev, O., Ta-Shma, A.: On the hardness of satisﬁability with bounded occurrences in the polynomial-time hierarchy. Theory Comput. 3(1), 45–60 (2007)
47. Littman, M.L., Majercik, S.M., Pitassi, T.: Stochastic Boolean satisﬁability. J. Autom. Reason. 27(3), 251–296 (2001)
48. Lund, C., Fortnow, L., Karloﬀ, H.J., Nisan, N.: Algebraic methods for interactive proof systems. J. ACM 39(4), 859–868 (1992)
49. Majercik, S.M.: APPSSAT: approximate probabilistic planning using stochastic satisﬁability. Int. J. Approximate Reasoning 45(2), 402–419 (2007)
50. Micali, S.: Computationally sound proofs. SIAM J. Comput. 30(4), 1253–1298 (2000). Preliminary version appeared in FOCS 1994
51. Papadimitriou, C.H.: Games against nature (extended abstract). In: 24th Annual ACM Symposium on Theory of Computing, STOC 1983,  (1983) 94 G. Arnon et al.
52. Reingold, O., Rothblum, R., Rothblum, G.: Constant-round interactive proofs for delegating computation. In: Proceedings of the 48th ACM Symposium on the The- ory of Computing, STOC 2016,  (2016)
53. Ron-Zewi, N., Rothblum, R.: Local proofs approaching the witness length. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science, FOCS 2020,  (2020)
54. Shamir, A.: IP = PSPACE. J. ACM 39(4), 869–877 (1992)
6. Br¨oker, R.: Constructing supersingular elliptic curves. J. Comb. Numb. Theory 1(3), 269–273 (2009)
11. Cooper, C.: On the rank of random matrices. Rand. Struct. Algor. 16(2), 209–232 (2000). https://doi.org/10.1002/(SICI)1098-2418(200003)16:2⟨209::AID- RSA6⟩3.0.CO;2-1
22. Grover, L.K.: A fast quantum mechanical algorithm for database search. In: 28th Annual ACM Symposium on Theory of Computing,  ACM Press, Philadephia (1996). https://doi.org/10.1145/237814.237866
25. Kovalenko, I., Levitskaya, A., Savchuk, M.: Selected Problems in Probabilistic Combinatorics. Naukova Dumka, Kiev (1986) M-SIDH and MD-SIDH: Countering SIDH Attacks by Masking Information 309
26. Maino, L., Martindale, C.: An attack on SIDH with arbitrary starting curve. Cryp- tology ePrint Archive, Report 2022/1026 (2022). https://eprint.iacr.org/2022/1026
35. Shor, P.W.: Algorithms for quantum computation: discrete logarithms and factor- ing. In: 35th Annual Symposium on Foundations of Computer Science, IEEE Computer Society Press, Santa Fe (1994). https://doi.org/10.1109/SFCS. 1994.365700
1. Alon, N.: Explicit expanders of every degree and size. Combinatorica 41(4), 447–463 (2021). https://doi.org/10.1007/s00493-020-4429-x
2. Appan, A., Chandramouli, A., Choudhury, A.: Perfectly-secure synchronous mpc with asynchronous fallback guarantees. In: Proceedings of the 2022 ACM Symposium on Principles of Distributed Computing.  (2022)
8. Bracha, G.: Asynchronous byzantine agreement protocols. Information and Com- putation 75(2), 130–143 (1987). https://doi.org/https://doi.org/10.1016/ 0890-5401(87)90054-X
10. Canetti, R., Rabin, T.: Fast asynchronous byzantine agreement with optimal resilience. In: 25th Annual ACM Symposium on Theory of Computing. ACM Press (May 1993). https://doi.org/10.1145/167088.167105
14. Dolev, D., Strong, H.R.: Authenticated algorithms for byzantine agreement. SIAM Journal on Computing 12(4), 656–666 (1983). https://doi.org/10.1137/0212045
16. Feldman, P., Micali, S.: Optimal algorithms for byzantine agreement. In: 20th Annual ACM Symposium on Theory of Computing.  ACM Press (May 1988). https://doi.org/10.1145/62212.62225 28
17. Fischer, M.J., Lynch, N.A., Paterson, M.S.: Impossibility of distributed consensus with one faulty process. Journal of the ACM (JACM) 32(2), 374–382 (1985)
20. Freitas, L., Kuznetsov, P., Tonkikh, A.: Distributed Randomness from Approximate Agreement. In: Scheideler, C. (ed.) 36th International Symposium on Distributed Computing (DISC 2022). Leibniz International Proceedings in Informatics (LIPIcs), vol. 246, pp. 24:1–24:21. Schloss Dagstuhl – Leibniz-Zentrum f¨ur Informatik, Dagstuhl, Germany (2022). https://doi.org/10.4230/LIPIcs.DISC.2022.24
23. Ghinea, D., Liu-Zhang, C.D., Wattenhofer, R.: Optimal synchronous approximate agreement with asynchronous fallback. In: Proceedings of the 2022 ACM Symposium on Principles of Distributed Computing.  (2022)
26. Karlin, A., Yao, A.: Probabilistic lower bounds for byzantine agreement. Unpub- lished document (1986)
30. Mehlhorn, K., Sun, H.: Great ideas in theoretical computer science (2013), https://resources.mpi-inf.mpg.de/departments/d1/teaching/ss13/gitcs/ lecture7.pdf
32. Momose, A., Ren, L.: Optimal communication complexity of authenticated byzan- tine agreement. In: Gilbert, S. (ed.) 35th International Symposium on Distributed Computing (DISC 2021). Leibniz International Proceedings in Informatics (LIPIcs), vol. 209, pp. 32:1–32:16. Schloss Dagstuhl – Leibniz-Zentrum f¨ur Informatik, Dagstuhl, Germany (2021). https://doi.org/10.4230/LIPIcs.DISC.2021.32
33. Most´efaoui, A., Moumen, H., Raynal, M.: Signature-free asynchronous binary byzantine consensus with t < n/3, O(n2) messages, and O(1) expected time. J. ACM 62(4) (2015). https://doi.org/10.1145/2785953
34. Most´efaoui, A., Raynal, M.: Signature-free broadcast-based intrusion tolerance: Never decide a byzantine value. In: Lu, C., Masuzawa, T., Mosbah, M. (eds.) Principles of Distributed Systems.  Springer Berlin Heidelberg, Berlin, Heidelberg (2010)
35. Most´efaoui, A., Raynal, M.: Signature-free asynchronous byzantine systems: From multivalued to binary consensus with t < n/3, O(n2) messages, and constant time. Acta Inf. 54(5), 501–520 (2017). https://doi.org/10.1007/s00236-016-0269-y
36. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. Decentralized business review (2008)
37. Nayak, K., Ren, L., Shi, E., Vaidya, N.H., Xiang, Z.: Improved extension pro- tocols for byzantine broadcast and agreement. In: Attiya, H. (ed.) 34th Inter- national Symposium on Distributed Computing (DISC 2020). Leibniz Interna- tional Proceedings in Informatics (LIPIcs), vol. 179, pp. 28:1–28:17. Schloss Dagstuhl–Leibniz-Zentrum f¨ur Informatik, Dagstuhl, Germany (2020). https: //doi.org/10.4230/LIPIcs.DISC.2020.28
39. Patra, A., Rangan, C.P.: Communication optimal multi-valued asynchronous byzantine agreement with optimal resilience. In: Fehr, S. (ed.) ICITS 11: 5th International Conference on Information Theoretic Security. Lecture Notes in Computer Science, vol. 6673,  Springer, Heidelberg (May 2011). https://doi.org/10.1007/978-3-642-20728-0_19
40. Pfitzmann, B., Waidner, M.: Information-theoretic pseudosignatures and byzantine agreement for t ≥n/3. IBM Research, Armonk, NY, USA (1996)
41. Reed, I.S., Solomon, G.: Polynomial codes over certain finite fields. Journal of the Society for Industrial and Applied Mathematics 8(2), 300–304 (1960). https: //doi.org/10.1137/0108018 30
2. Aldà, F., Aragona, R., Nicolodi, L., Sala, M.: Implementation and improvement of the partial sum attack on 6-round AES. In: Baldi, M., Tomasin, S. (eds.) Physical and Data-Link Security Techniques for Future Communication Systems. LNEE, vol. 358,  Springer, Cham (2016). https://doi.org/10.1007/978-3-319- 23609-4_12
3. Andoni, A., Indyk, P., Laarhoven, T., Razenshteyn, I., Schmidt, L.: Fast Fast Hadamard Transform. https://github.com/FALCONN-LIB/FFHT 156 O. Dunkelman et al.
17. Demirbaş, F., Kara, O.: Integral characteristics by keyspace partitioning. Des. Codes Crypt. 90(2), 443–472 (2022)
32. Yi, W., Chen, S., Wei, K.: Zero-correlation linear cryptanalysis of reduced round ARIA with partial-sum and FFT. arXiv preprint arXiv:1406.3240 (2014)
8. Canetti, R., Goldreich, O., Halevi, S.: The random oracle methodology, revisited (preliminary version). In: 30th ACM STOC,  ACM Press, May 1998. https://doi.org/10.1145/276698.276741
10. Canetti, R., Lindell, Y., Ostrovsky, R., Sahai, A.: Universally composable two- party and multi-party secure computation. In: 34th ACM STOC, ACM Press, May 2002. https://doi.org/10.1145/509907.509980
25. Garg, S., Srinivasan, A.: Garbled protocols and two-round MPC from bilinear maps. In: Umans, C. (ed.) 58th FOCS,  IEEE Computer Society Press, October 2017. https://doi.org/10.1109/FOCS.2017.60
26. Gen¸c, Z.A., Iovino, V., Rial, A.: “The simplest protocol for oblivious transfer” revis- ited. Inf. Process. Lett. 161, 105975 (2020). https://doi.org/10.1016/j.ipl.2020. 105975
27. Goldreich, O., Micali, S., Wigderson, A.: How to play any mental game or a com- pleteness theorem for protocols with honest majority. In: Aho, A. (ed.) 19th ACM STOC,  ACM Press, May 1987. https://doi.org/10.1145/28395.28420
30. Katz, J.: On achieving the “best of both worlds” in secure multiparty computation. In: Johnson, D.S., Feige, U. (eds.) 39th ACM STOC,  ACM Press, Jun 2007. https://doi.org/10.1145/1250790.1250793
32. Kondi, Y., Shelat, A.: Improved straight-line extraction in the random oracle model with applications to signature aggregation. In: Agrawal, S., Lin, D. (eds.) ASI- ACRYPT 2022,  Springer, Cham (2022). https://doi.org/10.1007/978- 3-031-22966-4 10
42. Zhou, Z., Zhang, B., Zhou, H.S., Ren, K.: Guc-secure commitments via random oracles: new impossibility and feasibility. In: Agrawal, S., Lin, D. (eds.) ASI- ACRYPT 2022,  Springer, Cham (2022). https://doi.org/10.1007/978- 3-031-22972-5 5
14. Knuth, D.E.: The Art of Computer Programming, Volume II: Seminumerical Algo- rithms. Addison-Wesley, New York (1969)
16. May, A.: Using LLL-reduction for solving RSA and factorization problems. In: Nguyen, P., Vallee, B. (eds.) The LLL Algorithm. Information Security and Cryp- tography. Springer, Berlin (2009). https://doi.org/10.1007/978-3-642-02295-1 10 Factoring with Only a Third of the Secret CRT-Exponents 167
20. Takayasu, A., Kunihiro, N.: Partial key exposure attacks on RSA: achieving the Boneh-Durfee bound. Theor. Comput. Sci. 761, 51–77 (2019)
1. Can we at least solve ZSVP in time better than 2n+o(n)? (In other words, can we at least do better than just plugging in an algorithm that solves SVP on all lattices?)
4. Do known algorithms perform any diﬀerently on rotations of Zn empirically? We essentially give positive answers to all of these questions, giving a richer perspective on ZSVP and related problems, as we detail below. Provably faster algorithms for Zn. Our ﬁrst main result, presented in Section 5, is an exponential-time algorithm for ZSVP that is faster than the fastest known algorithm for SVP over arbitrary lattices. In fact, we show something signiﬁcantly stronger: an eﬃcient dimension-preserving reduction from ZSVP to γ-approximate GapSVP over general lattices for any constant γ = O(1) (where GapSVP is the decision version of SVP in which the goal is simply to determine whether there exists a short vector, rather than to actually ﬁnd one). In other words, we show that in order to ﬁnd an exact shortest non-zero vector in a rotation of Zn, it suﬃces to simply approximate the length of a shortest non-zero vector in an arbitrary lattice. (In fact, we reduce to the γ-unique Shortest Vector Problem, which is SVP in which the shortest vector is guaranteed to be a factor of γ shorter than “the second shortest vector,” appropriately deﬁned.) Theorem 1.1 (Informal. See Corollary 5.4). There is an eﬃcient reduction from ZSVP to γ-approximate GapSVP (in fact, to γ-unique SVP, a potentially easier problem) in the same dimension for any constant γ = O(1). If we plug in the fastest known algorithm for O(1)-GapSVP, we immediately obtain a 2n/2+o(n)-time provably correct algorithm for ZSVP [ADRS15]. (And, under a purely geometric conjecture, we obtain a running time of (4/3)n+o(n) ≈20.415n [Ste20].) In fact, we show a similar result for exact SVP on a much larger class of lattices, speciﬁcally, lattices L with det(L′) ≥1 for all sublattices L′ ⊆L and with λ1(L) not too large (lattices satisfying the former condition are called semi-stable). While this generalized algorithm is not directly related to the remainder of our work, it is related to
[CHKP12] introduced the idea of sampling a “discrete Gaussian basis” from an arbitrary basis. More recently, in independent work that was published on ePrint before this work,
[DvW22] decryption algorithm recovers the unique lattice vector within this distance of the target point. In this context, Zn is not a particularly good lattice because its unique decoding radius is rather small (relative to, e.g., its determinant). (Of course, Ducas and van Woerden list many “remarkable” lattices, many of which are better suited to their construction.) In contrast, our ciphertext is a target point that is quite far away from the lattice, at distance Θ(√n) (well above the radius at which unique decoding is possible), and our decryption algorithm simply determines whether the target is closer or farther than a certain threshold value. Indeed, our scheme is particularly well suited to Zn, as we discuss in Section 4.4. Because of this diﬀerence, our scheme achieves security under arguably weaker hardness assumptions (because we work at much larger radii), but each of our ciphertexts encodes just a single-bit plaintext, while
[DvW22] encode many plaintext bits in each ciphertext (or, more accurately, they construct a KEM). The assumptions are not directly comparable, however, as [DvW22]’s hardness assumptions concern the lattice Zn ⊕αZn for a cleverly chosen scaling factor α, whereas our hardness assumptions work with Zn directly. Ducas and van Woerden also show a signature scheme and a zero-knowledge proof, while we do not. Ducas and van Woerden’s work also contains more-or-less the same worst-case to average-case reduction that we describe in Section 3, and therefore also more-or-less the same distribution of bases that we propose. Indeed, in this case their work is essentially strictly more general than ours. (Similar ideas also appeared in [CHKP12, HR14, AEN], though in diﬀerent contexts. Our proofs in Section 3 immediately generalize to other lattices.) Blanks and Miller introduced two of the basis-generating procedures that we study, and performed experiments on them to determine if basis reduction algorithms could break them [BM21]. Our empirical work on diﬀerent bases for Zn is best viewed as follow-up work to [BM21]. In particular, we perform more trials and run BKZ with larger block sizes. Additionally, we perform experiments on the discrete Gaussian bases described above, which were not considered in [BM21]. Finally, we note that recent follow-up work to this paper
[BL23] has continued the study of the cryp- 5 tosystem that we propose. Speciﬁcally,
[fSC18] International Organization for Standardization and International Elec- trotechnical Commission. It security techniques - digital signatures with
6. Boneh, D., Canetti, R., Halevi, S., Katz, J.: Chosen-ciphertext security from identity-based encryption. SIAM J. Comput. 36(5), 1301–1328 (2007)
3. Albrecht, M.R., Cid, C., Faug`ere, J.C., Fitzpatrick, R., Perret, L.: On the com- plexity of the BKW algorithm on LWE. Des. Codes Crypt. 74(2), 325–354 (2015)
12. Becker, A., Ducas, L., Gama, N., Laarhoven, T.: New directions in nearest neigh- bor searching with applications to lattice sieving. In: Proceedings of the Twenty- Seventh Annual ACM-SIAM Symposium on Discrete Algorithms,  SIAM (2016)
16. Blum, A., Kalai, A., Wasserman, H.: Noise-tolerant learning, the parity problem, and the statistical query model. J. ACM 50(4), 506–519 (2003)
18. Brakerski, Z., Gentry, C., Vaikuntanathan, V.: (Leveled) Fully homomorphic encryption without bootstrapping. In: Proceedings of the 3rd Innovations in The- oretical Computer Science Conference,  ACM (2012)
20. Carlitz, L., Uchiyama, S.: Bounds for exponential sums. Duke Math. J. 24(1), 37–41 (1957)
22. Chen, Y.: R´eduction de R´eseau et S´ecurit´e Concr`ete du Chiﬀrement Compl`etement Homomorphe. Ph.D. thesis (2013). th`ese de doctorat dirig´ee par Nguyen, Phong- Quang Informatique Paris 7 2013
33. Dworkin, M.J.: SHA-3 standard: permutation-based hash and extendable-output functions. Technical report. National Institute of Standards and Technology (2015)
35. Fr¨oberg, R.: An inequality for Hilbert series of graded algebras. Mathematica Scan- dinavica 56, 117–144 (1985)
42. Ha, J., et al.: Masta: an HE-friendly cipher using modular arithmetic. IEEE Access 8, 194741–194751 (2020)
54. Naehrig, M., Lauter, K., Vaikuntanathan, V.: Can homomorphic encryption be practical? In: Proceedings of the 3rd ACM Workshop on Cloud Computing Security Workshop,  ACM (2011)
55. Park, S., Byun, J., Lee, J., Cheon, J.H., Lee, J.: HE-friendly algorithm for privacy- preserving SVM training. IEEE Access 8, 57414–57425 (2020)
59. Schnorr, C.P., Euchner, M.: Lattice basis reduction: improved practical algorithms and solving subset sum problems. Math. Program. 66(1), 181–199 (1994)
1. Applebaum, B.: Pseudorandom generators with long stretch and low locality from random local one-way functions. In: Karloﬀ, H.J., Pitassi, T. (eds.) 44th ACM STOC,  ACM Press, May 2012. https://doi.org/10.1145/2213977. 2214050
4. Applebaum, B., Lovett, S.: Algebraic attacks against random local functions and their countermeasures. In: Wichs, D., Mansour, Y. (eds.) 48th ACM STOC,  ACM Press, June 2016. https://doi.org/10.1145/2897518.2897554
9. Bardet, M., Faugère, J.-C., Salvy, B.: Complexity of Gröbner basis computation for Semi-regular Overdetermined sequences over F_2 with solutions in F_2 Research Report RR-5049 (INRIA) (2003). https://hal.inria.fr/inria-00071534
10. Bardet, M., Faugère, J.-C., Salvy, B.: On the complexity of Gröbner basis com- putation of semi-regular overdetermined algebraic equations. https://doi.org/10. 1016/j.jsc.2015.12.001
14. Caminata, A., Gorla, E.: Solving degree, last fall degree, and related invariants. J. Symb. Comput. 114, 322–335 (2023). ISSN: 0747-7171
24. Faugére, J.-C.: A new eﬃcient algorithm for computing Gröbner bases (F4). J. Pure Appl. Algebra 139, 61–88 (1999). ISSN: 0022-4049
25. Goemans, M.X., Williamson, D.P.: Improved approximation algorithms for maxi- mum cut and satisﬁability problems using semideﬁnite programming. J. ACM 42, 1115–1145 (1995). ISSN: 0004-5411
27. Håstad, J., Impagliazzo, R., Levin, L.A., Luby, M.: A pseudorandom generator from any one-way function. SIAM J. Comput. 28, 1364–1396 (1999) Worst-Case Subexponential Attacks on PRGs of Constant Degree 53
29. Impagliazzo, R., Wigderson, A.: P = BPP if E requires exponential circuits: deran- domizing the XOR lemma. In: 29th ACM STOC,  ACM Press, May 1997. https://doi.org/10.1145/258533.258590
33. Lang, S.: Algebra. Springer, New York (2002). ISBN: 9781461300410 146130041X. https://doi.org/10.1007/978-1-4613-0041-0
35. Macaulay, F.: The Algebraic Theory of Modular Systems. Cambridge Mathemati- cal Library xxxi (1916). https://doi.org/10.3792/chmm/1263317740
37. Mossel, E., Shpilka, A., Trevisan, L.: On e-biased generators in NC0. In: 44th FOCS,  IEEE Computer Society Press, October 2003. https://doi. org/10.1109/SFCS.2003.1238188
38. Nisan, N., Wigderson, A.: Hardness vs. randomness (Extended Abstract). In: 29th FOCS,  IEEE Computer Society Press, October 1988. https://doi.org/ 10.1109/SFCS.1988.21916
39. ODonnell, R., Witmer, D.: Goldreich’s PRG: evidence for near-optimal polynomial stretch, , June 2014. ISBN: 978-1-4799-3626-7. https://doi.org/10.1109/ CCC.2014.9
40. Schwartz, J.T.: Fast probabilistic algorithms for veriﬁcation of polynomial identi- ties. J. ACM 27, 701–717 (1980). ISSN: 0004-5411
41. Siegenthaler, T.: Correlation-immunity of nonlinear combining functions for cryp- tographic applications (Corresp.). IEEE Trans. Inform. Theory 30, 776–780 (1984)
42. Sugita, M., Kawazoe, M., Imai, H.: Relation between the XL algorithm and Gröb- ner basis algorithms. IEICE Trans. Fundam. Electron. Commun. Comput. Sci. E89-A, 11–18 (2006). ISSN: 0916-8508
43. Viola, E.: The sum of d small-bias generators fools polynomials of degree d. In: 2008 23rd Annual IEEE Conference on Computational Complexity, (2008). https://doi.org/10.1109/CCC.2008.16 54 A. Ünal
6. Aharonov, D., Ben-Or, M., Eban, E.: Interactive proofs for quantum computations. In: International Conference on Supercomputing (2008)
10. Bao, J., Ji, L., Wei, R., Zhang, Y.: New existence and nonexistence results for strong external diﬀerence families. Discret. Math. 341, 1798–1805 (2016)
11. Barnum, H., Cr´epeau, C., Gottesman, D., Smith, A., Tapp, A.: Authentication of quantum messages. In: The 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002. Proceedings,  IEEE (2002)
12. Barnum, H., Knill, E.: Reversing quantum dynamics with near-optimal quantum and classical ﬁdelity. J. Math. Phys. 43, 2097–2106 (2000)
13. Ben-Aroya, A., Doron, D., Ta-Shma, A.: Near-optimal erasure list-decodable codes. In: Proceedings of the 35th Computational Complexity Conference (2020)
15. B´eny, C., Oreshkov, O.: General conditions for approximate quantum error correc- tion and near-optimal recovery channels. Phys. Rev. Lett. 104(12), 120501 (2010)
16. Bergamaschi, T., Boddu, N.G.: On split-state quantum tamper detection and non- malleability (2023). https://api.semanticscholar.org/CorpusID:265456980
17. Bergamaschi, T., Golowich, L., Gunn, S.: Approaching the quantum singleton bound with approximate error correction. arXiv abs/2212.09935 (2022)
18. Boddu, N.G., Goyal, V., Jain, R., Ribeiro, J.L.: Split-state non-malleable codes and secret sharing schemes for quantum messages. ArXiv abs/2308.06466 (2023). https://api.semanticscholar.org/CorpusID:260886799
19. Boddu, N.G., Jain, R.: Non-malleable code in the split-state model. Entropy 24 (2022). https://api.semanticscholar.org/CorpusID:208058906
20. Boddu, N.G., Kapshikar, U.: Tamper detection against unitary operators. ArXiv abs/2105.04487 (2021)
21. Calderbank, S.: Good quantum error-correcting codes exist. Phys. Rev. A Atom. Mol. Opt. Phys. 54(2), 1098–1105 (1996)
23. Cleve, R., Gottesman, D., Lo, H.K.: How to share a quantum secret. Phys. Rev. Lett. 83, 648–651 (1999)
27. Cramer, R., Fehr, S., Padr´o, C.: Algebraic manipulation detection codes. Sci. China Math. 56, 1349–1358 (2013). https://api.semanticscholar.org/CorpusID:31391230
30. Devetak, I.: The private classical capacity and quantum capacity of a quantum channel. IEEE Trans. Inf. Theory 51, 44–55 (2005)
31. Ding, Y., Jin, L., Xing, C.: Erasure list-decodable codes from random and algebraic geometry codes. IEEE Trans. Inf. Theory 60, 3889–3894 (2014)
33. Dziembowski, S., Pietrzak, K., Wichs, D.: Non-malleable codes (2018). https:// api.semanticscholar.org/CorpusID:14293524
34. Elias, P.: List decoding for noisy channels. In: Technical Report 335. Research Laboratory of Electronics, MIT (1957)
35. Gottesman, D.: Stabilizer codes and quantum error correction. arXiv: Quantum Physics (1997)
36. Gottesman, D.: Theory of quantum secret sharing. Phys. Rev. A 61, 042311 (1999)
37. Grassl, M., Huber, F., Winter, A.J.: Entropic proofs of singleton bounds for quan- tum error-correcting codes. IEEE Trans. Inf. Theory 68, 3942–3950 (2020)
38. Gullans, M.J., Krastanov, S., Huse, D.A., Jiang, L., Flammia, S.T.: Quantum coding with low-depth random circuits. Phys. Rev. X 11, 031066 (2020)
39. Guruswami, V.: List decoding from erasures: bounds and code constructions. IEEE Trans. Inf. Theory 49, 2826–2833 (2001)
40. Hayden, P.M., Leung, D.W., Mayers, D.: The universal composable security of quantum message authentication with key recyling. arXiv: Quantum Physics (2016)
41. Hayden, P.M., Penington, G.: Approximate quantum error correction revisited: introducing the alpha-bit. Commun. Math. Phys. 374, 369–432 (2017)
42. Huczynska, S., Paterson, M.B.: Existence and non-existence results for strong external diﬀerence families. Discret. Math. 341, 87–95 (2016)
43. Huczynska, S., Paterson, M.B.: Weighted external diﬀerence families and R-optimal AMD codes. Discret. Math. 342, 855–867 (2018)
46. Knill, E., Laﬂamme, R.: Theory of quantum error-correcting codes. Phys. Rev. A 55, 900–911 (1996) Pauli Manipulation Detection Codes and Applications 433
47. Kretschmann, D., Schlingemann, D., Werner, R.F.: The information-disturbance tradeoﬀand the continuity of Stinespring’s representation. IEEE Trans. Inf. Theory 54, 1708–1717 (2006)
48. Leung, D.W., Nielsen, M.A., Chuang, I.L., Yamamoto, Y.: Approximate quantum error correction can lead to better codes. Phys. Rev. A 56, 2567–2573 (1997)
49. Leung, D.W., Smith, G.: Communicating over adversarial quantum channels using quantum list codes. IEEE Trans. Inf. Theory 54, 883–887 (2006)
51. Mandayam, P., Ng, H.K.: Towards a uniﬁed framework for approximate quan- tum error correction. Phys. Rev. A 86, 012335 (2012). https://doi.org/10.1103/ PhysRevA.86.012335. https://link.aps.org/doi/10.1103/PhysRevA.86.012335
52. Ng, H.K., Mandayam, P.: Simple approach to approximate quantum error cor- rection based on the transpose channel. Phys. Rev. A 81, 062342 (2010). https://doi.org/10.1103/PhysRevA.81.062342. https://link.aps.org/doi/10.1103/ PhysRevA.81.062342
53. Rains, E.M.: Quantum shadow enumerators. IEEE Trans. Inf. Theory 45, 2361– 2366 (1996)
54. Rains, E.M.: Nonbinary quantum codes. IEEE Trans. Inf. Theory 45, 1827–1832 (1997)
55. Schumacher, B., Westmoreland, M.D.: Approximate quantum error correc- tion. Quantum Inf. Process. 1(1-2), 5–12 (2002). https://doi.org/10.1023/A %3A1019653202562
56. Smith, A.D.: Quantum secret sharing for general access structures. arXiv: Quantum Physics (2000)
57. Steane: Simple quantum error-correcting codes. Phys. Rev. A Atom. Mol. Opt. Phys. 54 6, 4741–4751 (1996)
58. Wozencraft., J.M.: List Decoding. Quarterly Progress Report, Research Laboratory of Electronics, vol. 48,  MIT (1958)
59. Wu, Y., Kolkowitz, S., Puri, S., Thompson, J.D.: Erasure conversion for fault- tolerant quantum computing in alkaline earth Rydberg atom arrays. Nat. Commun. 13, 4657 (2022)
60. Yoshida, B., Kitaev, A.Y.: Eﬃcient decoding for the Hayden-Preskill protocol. arXiv: High Energy Physics - Theory (2017)
1. Aaronson, S., Ambainis, A.: Forrelation: a problem that optimally separates quan- tum from classical computing. SIAM J. Comput. 47(3), 982–1038 (2018)
2. Aaronson, S., Ben-David, S., Kothari, R.: Separations in query complexity using cheat sheets. In: STOC,  ACM (2016)
3. Aaronson, S., Ben-David, S., Kothari, R., Tal, A.: Quantum implications of huang’s sensitivity theorem. Electron. Colloquium Comput. Complex. 27, 66 (2020)
4. Ambainis, A., Balodis, K., Belovs, A., Lee, T., Santha, M., Smotrovs, J.: Sepa- rations in query complexity based on pointer functions. In: STOC, ACM (2016)
8. Beals, R., Buhrman, H., Cleve, R., Mosca, M., de Wolf, R.: Quantum lower bounds by polynomials. J. ACM 48(4), 778–797 (2001)
9. Bennett, C.H.: Time/space trade-oﬀs for reversible computation. SIAM J. Comput. 18(4), 766–776 (1989)
16. Brassard, G., Hoyer, P., Mosca, M., Tapp, A.: Quantum amplitude ampliﬁcation and estimation. Contemp. Math. 305, 53–74 (2002)
26. Grover, L.K.: A fast quantum mechanical algorithm for database search. In: STOC, ACM (1996)
33. Jaeger, J., Song, F., Tessaro, S.: Quantum key-length extension. CoRR abs/2105.01242 (2021)
38. Knill, E.: An analysis of bennett’s pebble game. CoRR abs/math/9508218 (1995)
39. Kuwakado, H., Morii, M.: Quantum distinguisher between the 3-round feistel cipher and the random permutation. In: ISIT,  IEEE (2010)
40. Kuwakado, H., Morii, M.: Security on the quantum-type even-mansour cipher. In: ISITA,  IEEE (2012)
42. Levin, R.Y., Sherman, A.T.: A note on Bennett’s time-space tradeoﬀfor reversible computation. SIAM J. Comput. 19(4), 673–677 (1990)
43. Magniez, F., Nayak, A., Roland, J., Santha, M.: Search via quantum walk. SIAM J. Comput. 40(1), 142–164 (2011)
44. National Academies of Sciences: Engineering, and Medicine: Quantum Computing: Progress and Prospects. The National Academies Press, Washington, DC (2018)
45. Nielsen, M.A., Chuang, I.: Quantum computation and quantum information (2002)
46. Sherstov, A.A., Storozhenko, A.A., Wu, P.: An optimal separation of randomized and quantum query complexity. In: STOC,  ACM (2021)
47. Shor, P.W.: Algorithms for quantum computation: Discrete logarithms and factor- ing. In: FOCS,  IEEE Computer Society (1994)
48. Simon, D.R.: On the power of quantum computation. SIAM J. Comput. 26(5), 1474–1483 (1997)
50. Zalka, C.: Grover’s quantum searching algorithm is optimal. Phys. Rev. A 60(4), 2746 (1999)
8. Bhattacharjee, A., Bhaumik, R., Nandi, M.: Oﬀset-based bbb-secure tweakable block-ciphers with updatable caches. In: INDOCRYPT. Lecture Notes in Computer Science, vol. 13774,  Springer (2022). https://doi.org/10.1007/978-3- 031-22912-1_8
17. Dutta, A., Nandi, M., Saha, A.: Proof of mirror theory for xi_max=2. IEEE Trans. Inf. Theor. 68(9), 6218–6232 (2022). https://doi.org/10.1109/TIT.2022.3171178 560 Z. Bao et al.
40. Sovyn, Y., Khoma, V., Podpora, M.: Comparison of three CPU-core families for IoT applications in terms of security and performance of AES-GCM. IEEE Internet Things J. 7(1), 339–348 (2020). https://doi.org/10.1109/JIOT.2019.2953230
2. Ambainis, A.: Quantum walk algorithm for element distinctness. SIAM J. Comput. 37(1), 210–239 (2007)
3. Babai, L.: Graph isomorphism in quasipolynomial time [extended abstract]. In: Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Com- puting, STOC 2016, Cambridge, MA, USA, 18–21 June 2016,  (2016)
4. Babai, L.: Canonical form for graphs in quasipolynomial time: preliminary report. In: Charikar, M., Cohen, E. (eds.) Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, 23–26 June 2019,  ACM (2019). https://doi.org/10.1145/3313276.3316356
7. Bardet, M., Otmani, A., Saeed-Taha, M.: Permutation code equivalence is not harder than graph isomorphism when hulls are trivial. In: 2019 IEEE International Symposium on Information Theory (ISIT),  IEEE (2019). https:// doi.org/10.1109/ISIT.2019.8849855
8. Barenghi, A., Biasse, J.F., Ngo, T., Persichetti, E., Santini, P.: Advanced signature functionalities from the code equivalence problem. Int. J. Comput. Math. Comput. Syst. Theory 7(2), 112–128 (2022)
15. Bl¨aser, M., et al.: The ALTEQ signature scheme: algorithm speciﬁcations and supporting documentation (2023). https://pqcalteq.github.io/ALTEQ spec 2023. 09.18.pdf 186 A. K. Narayanan et al.
16. Bosma, W., Cannon, J., Playoust, C.: The Magma algebra system. I. The user language. J. Symbolic Comput. 24(3–4), 235–265 (1997). https://doi.org/10.1006/ jsco.1996.0125. Computational algebra and number theory, London (1993)
20. B¨urgisser, P., Franks, C., Garg, A., de Oliveira, R.M., Walter, M., Wigderson, A.: Eﬃcient algorithms for tensor scaling, quantum marginals, and moment polytopes. In: 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, 7–9 October 2018,  (2018). https://doi.org/10. 1109/FOCS.2018.00088
23. Couvreur, A., Debris-Alazard, T., Gaborit, P.: On the hardness of code equivalence problems in rank metric. arXiv preprint arXiv:2011.04611 (2020)
29. Fulman, J., Goldstein, L.: Stein’s method and the rank distribution of random matrices over ﬁnite ﬁelds. Ann. Probab. 43(3) (2015). https://doi.org/10.1214/ 13-aop889
30. Goldreich, O., Micali, S., Wigderson, A.: Proofs that yield nothing but their validity for all languages in NP have zero-knowledge proof systems. J. ACM 38(3), 691–729 (1991). https://doi.org/10.1145/116825.116852
31. Grochow, J.A., Qiao, Y.: On the complexity of isomorphism problems for tensors, groups, and polynomials I: tensor isomorphism-completeness. SIAM J. Comput. 52(2), 568–617 (2023) Algorithms for Matrix Code and Trilinear Form Equivalences 187
32. Grochow, J.A., Qiao, Y., Tang, G.: Average-case algorithms for testing isomor- phism of polynomials, algebras, and multilinear forms. J. Groups Complex. Cryp- tol. 14 (2022)
33. Grover, L.K.: A fast quantum mechanical algorithm for database search. In: Pro- ceedings of the Twenty-Eighth Annual ACM Symposium on Theory of Computing, (1996)
36. Leon, J.: Computing automorphism groups of error-correcting codes. IEEE Trans. Inf. Theory 28(3), 496–511 (1982)
37. Magniez, F., Nayak, A., Richter, P.C., Santha, M.: On the hitting times of quantum versus random walks. Algorithmica 63, 91–116 (2012)
38. Magniez, F., Nayak, A., Roland, J., Santha, M.: Search via quantum walk. In: Pro- ceedings of the Thirty-Ninth Annual ACM Symposium on Theory of Computing, (2007)
40. Sendrier, N.: Finding the permutation between equivalent linear codes: the support splitting algorithm. IEEE Trans. Inf. Theory 46(4), 1193–1203 (2000)
41. Szegedy, M.: Spectra of quantized walks and a √ δϵ-rule. arXiv preprint quant- ph/0401053 (2004)
43. Tani, S.: Claw ﬁnding algorithms using quantum walk. Theoret. Comput. Sci. 410(50), 5285–5297 (2009)
4. Brown, D.R.L.: Generic groups, collision resistance, and ECDSA. Des. Codes Crypt. 35, 119–152 (2002)
10. Fersch, M., Kiltz, E., Poettering, B.: On the provable security of (EC)DSA signa- tures. In: 2016 ACM SIGSAC,  ACM (2016)
14. Nechaev, V.I.: Complexity of a determinate algorithm for the discrete logarithm. Math. Notes 55(2), 165–172 (1994). translated from Matematicheskie Zametki, 55(2):91–101, 1994
1. Beigel, R., Fortnow, L., Gasarch, W.I.: A nearly tight bound for private informa- tion retrieval protocols. In: Electronic Colloquium on Computational Complexity (ECCC) (2003)
9. Chor, B., Gilboa, N.: Computationally private information retrieval. In: STOC (1997)
10. Chor, B., Goldreich, O., Kushilevitz, E., Sudan, M.: Private information retrieval. In: FOCS (1995)
11. Connell, G.: Technology deep dive: Building a faster ORAM layer for enclaves. https://signal.org/blog/building-faster-oram/
14. Demmler, D., Rindal, P., Rosulek, M., Trieu, N.: PIR-PSI: scaling private contact discovery. Proc. Priv. Enhancing Technol. 2018(4), 159–178 (2018)
17. Dvir, Z., Gopi, S.: 2-server PIR with subpolynomial communication. J. ACM 63(4) (2016)
18. Feamster, N.: Oblivious DNS deployed by Cloudﬂare and Apple. https://medium. com/noise-lab/oblivious-dns-deployed-by-cloudﬂare-and-apple-1522ccf53cab
21. Henzinger, A., Dauterman, E., Corrigan-Gibbs, H., Zeldovich, N.: Private web search with Tiptoe. In: 29th ACM Symposium on Operating Systems Principles (SOSP), Koblenz, Germany (2023)
24. Impagliazzo, R., Rudich, S.: Limits on the provable consequences of one-way per- mutations. In: Proceedings of the 21st Annual ACM Symposium on Theory of Computing, Seattle, Washington, USA, 14–17 May 1989,  ACM (1989)
26. Kushilevitz, E., Ostrovsky, R.: Replication is not needed: single database, computationally-private information retrieval. In: FOCS (1997)
29. Lin, W.K., Mook, E., Wichs, D.: Doubly eﬃcient private information retrieval and fully homomorphic ram computation from ring LWE. In: STOC (2023)
31. Melchor, C.A., Crespin, B., Gaborit, P., Jolivet, V., Rousseau, P.: High-speed pri- vate information retrieval computation on GPU. In: Proceedings of the 2008 Second International Conference on Emerging Security Information, Systems and Technolo- gies, SECURWARE 2008, Washington, DC, USA,  IEEE Computer Society (2008)
37. Pagh, R., Rodler, F.F.: Cuckoo hashing. J. Algorithms 51(2), 122–144 (2004)
43. Zhou, M., Park, A., Shi, E., Zheng, W.: Piano: extremely simple, single-server PIR with sublinear server computation. In: IEEE S& P (2024)
15. Bitansky, N., Vaikuntanathan, V.: Indistinguishability obfuscation from functional encryption. In: Guruswami, V. (ed.) 56th FOCS,  IEEE Computer Society Press (2015). https://doi.org/10.1109/FOCS.2015.20
27. Garg, S., Gentry, C., Sahai, A., Waters, B.: Witness encryption and its applications. In: Boneh, D., Roughgarden, T., Feigenbaum, J. (eds.) 45th ACM STOC,  ACM Press (2013). https://doi.org/10.1145/2488608.2488667
28. Gay, R., Pass, R.: Indistinguishability obfuscation from circular security. In: Khuller, S., Williams, V.V. (eds.) STOC 2021: 53rd Annual ACM SIGACT Sympo- sium on Theory of Computing, Virtual Event, Italy, 21–25 June 2021, ACM (2021). https://doi.org/10.1145/3406325.3451070
31. Goyal, R., Koppula, V., Waters, B.: Lockable obfuscation. In: Umans, C. (ed.) 58th FOCS,  IEEE Computer Society Press (2017). https://doi.org/ 10.1109/FOCS.2017.62
33. Halevi, S., Ishai, Y., Jain, A., Kushilevitz, E., Rabin, T.: Secure multiparty com- putation with general interaction patterns. In: Sudan, M. (ed.) ITCS 2016,  ACM (2016). https://doi.org/10.1145/2840728.2840760
35. Jain, A., Lin, H., Sahai, A.: Indistinguishability obfuscation from well-founded assumptions. In: Khuller, S., Williams, V.V. (eds.) STOC 2021: 53rd Annual ACM SIGACT Symposium on Theory of Computing, Virtual Event, Italy, 21–25 June 2021,  ACM (2021). https://doi.org/10.1145/3406325.3451093
40. L´opez-Alt, A., Tromer, E., Vaikuntanathan, V.: On-the-ﬂy multiparty computation on the cloud via multikey fully homomorphic encryption. In: Karloﬀ, H.J., Pitassi, T. (eds.) 44th ACM STOC,  ACM Press (2012). https://doi.org/ 10.1145/2213977.2214086
48. Wichs, D., Zirdelis, G.: Obfuscating compute-and-compare programs under LWE. In: Umans, C. (ed.) 58th FOCS,  IEEE Computer Society Press (2017). https://doi.org/10.1109/FOCS.2017.61
9. Camenisch, J.: Group signature schemes and payment systems based on the dis- crete logarithm problem. Ph.D. thesis, ETH Zurich, Z¨urich, Switzerland (1998)
18. Davidson, A., Goldberg, I., Sullivan, N., Tankersley, G., Valsorda, F.: Privacy pass: bypassing internet challenges anonymously. Proc. Priv. Enhancing Technol. 2018(3), 164–180 (2018)
26. Huang, S., et al.: PrivateStats: De-Identiﬁed Authenticated Logging at Scale, Jan- uary 2021. https://research.fb.com/wp-content/uploads/2021/01/PrivateStats- De-Identiﬁed-Authenticated-Logging-at-Scale ﬁnal.pdf
39. Naor, M., Reingold, O.: Number-theoretic constructions of eﬃcient pseudo-random functions. In: FOCS,  IEEE Computer Society (1997)
45. Wilander, J., Taubeneck, E., Knox, A., Wood, C.: Consider using blinded signa- tures for fraud prevention - Private Click Measurement (2020). https://github. com/privacycg/private-click-measurement/issues/41 A Fast and Simple Partially Oblivious PRF, with Applications 705
9. Canetti, R., Goldreich, O., Goldwasser, S., Micali, S.: Resettable zero-knowledge (extended abstract). In: 32nd ACM STOC,  ACM Press, May 2000. https://doi.org/10.1145/335305.335334
10. Canetti, R., Lin, H., Pass, R.: Adaptive hardness and composable security in the plain model from standard assumptions. In: 51st FOCS,  IEEE Com- puter Society Press, October 2010. https://doi.org/10.1109/FOCS.2010.86
11. Chung, K., Lin, H., Mahmoody, M., Pass, R.: On the power of nonuniformity in proofs of security. In: Kleinberg, R.D. (ed.) ITCS ’13, Berkeley, CA, USA, 9-12 Jan- uary 2013,  ACM (2013). https://doi.org/10.1145/2422436.2422480
15. Deng, Y., Goyal, V., Sahai, A.: Resolving the simultaneous resettability conjecture and a new non-black-box simulation strategy. In: 50th FOCS,  IEEE Computer Society Press, October 2009. https://doi.org/10.1109/FOCS.2009.59
18. Dodis, Y., Reyzin, L.: On the power of claw-free permutations. In: Cimato, S., Galdi, C., Persiano, G. (eds.) SCN
34. Pass, R.: Limits of provable security from standard assumptions. In: Fortnow, L., Vadhan, S.P. (eds.) 43rd ACM STOC.  ACM Press, June 2011. https://doi.org/10.1145/1993636.1993652
10. Hashimoto, Y.: High-rank attack on hmfev. JSIAM Letters 10, 21–24 (2018). https://doi.org/10.14495/jsiaml.10.21
13. Patarin, J., Goubin, L.: Trapdoor one-way permutations and multivariate poly- nominals. In: Han, Y., Okamoto, T., Qing, S. (eds.) Information and Communica- tion Security, First International Conference, ICICS’97, Beijing, China, November 11-14, 1997, Proceedings. Lecture Notes in Computer Science, vol. 1334,  Springer (1997). https://doi.org/10.1007/BFb0028491, https://doi.org/ 10.1007/BFb0028491
16. Volker, S.: Gaussian Elimination is not Optimal. Numerische Mathematik 13, 354– 356 (1969)
[8] on Modeling 1 with one variable xi, i ̸= 5, fixed to a nonzero value (for security level I). ******* STEP 1 Basis length: 49, queue length: 310, step degree: 2, num pairs: 10 Basis total mons: 146, average length: 2.980 Number of S-polynomials: 10, different lcms: 10 Number of pair polynomials: 10, at 23 column(s), 0.000 Average length for reductees: 2.00 [10], reductors: 3.00 [10] Symbolic reduction time: 0.000, column sort time: 0.000 10 + 10 = 20 rows / 23 columns out of 171 (13.450%) Density: 10.87% / 13.854% (2.5/r), total: 50 (0.0MB) Matrix construction time: 0.000 Matrix size: 20 by 23 Current max memory usage: 32.1MB (=max) Before ech memory: 32.1MB (=max) Row sort time: 0.000 0.000 + 0.000 + 0.000 = 0.000 [10] Echelonization time: 0.000 After ech memory: 32.1MB (=max) New rules time: 0.000 Num new polynomials: 10 (100.0%), min deg: 1 [10], av deg: 1.0 Degree counts: 1:10 Queue insertion time: 0.000 Number of linears: 10 New max step: 1, time: 0.000 Step 1 time: 0.000, [0.001], mat/total: 0.000/0.000, mem: 32.1MB (=max) ******* STEP 2 Basis length: 59, queue length: 338, step degree: 2, num pairs: 38 Basis total mons: 176, average length: 2.983 Number of S-polynomials: 38, different lcms: 38 Number of pair polynomials: 38, at 53 column(s), 0.000 Average length for reductees: 3.00 [38], reductors: 3.00 [38] Symbolic reduction time: 0.000, column sort time: 0.000 38 + 38 = 76 rows / 53 columns out of 171 (30.994%) Density: 5.6604% / 9.7791% (3/r), total: 228 (0.0MB) Matrix construction time: 0.000 Matrix size: 76 by 53 Current max memory usage: 32.1MB (=max) Before ech memory: 32.1MB (=max) Row sort time: 0.000 0.000 + 0.000 + 0.000 = 0.000 [13] Echelonization time: 0.000 After ech memory: 32.1MB (=max) New rules time: 0.000 Num new polynomials: 13 (34.2%), min deg: 1 [5], av deg: 1.6 Degree counts: 1:5 2:8 Queue insertion time: 0.000 Number of linears: 15 Step 2 time: 0.000, [0.001], mat/total: 0.000/0.000, mem: 32.1MB (=max) Practical Attack on All Parameters of the DME Signature Scheme 27 ******* STEP 3 Basis length: 72, queue length: 308, step degree: 2, num pairs: 8 Basis total mons: 215, average length: 2.986 Number of S-polynomials: 8, different lcms: 8 Number of pair polynomials: 8, at 15 column(s), 0.000 Average length for reductees: 3.00 [8], reductors: 3.00 [12] Symbolic reduction time: 0.000, column sort time: 0.000 8 + 12 = 20 rows / 15 columns out of 171 (8.772%) Density: 20% / 36.011% (3/r), total: 60 (0.0MB) Matrix construction time: 0.000 Matrix size: 20 by 15 Current max memory usage: 32.1MB (=max) Before ech memory: 32.1MB (=max) Row sort time: 0.000 0.000 + 0.000 + 0.000 = 0.000 [1] Echelonization time: 0.000 After ech memory: 32.1MB (=max) New rules time: 0.000 Num new polynomials: 1 (12.5%), min deg: 2 [1], av deg: 2.0 Degree counts: 2:1 Queue insertion time: 0.000 Number of linears: 15 Step 3 time: 0.000, [0.001], mat/total: 0.000/0.000, mem: 32.1MB (=max) ******* STEP 4 Basis length: 73, queue length: 300, step degree: 3, num pairs: 300 Basis total mons: 218, average length: 2.986 300 pairs eliminated No pairs to reduce Pair elimination time: 0.000 Do extern interreduction (length 25) INTERREDUCE 17 polynomial(s) Symbolic reduction time: 0.000 Column sort time: 0.000 17 + 0 = 17 rows / 19 columns Density: 15.48% / 35.791% (2.9412/r), total: 50 (0.0MB) Row sort time: 0.000 0.000 + 0.000 = 0.000 [17] Echelonization time: 0.000 Total reduction time: 0.000 Reduction time: 0.000 Final extern interreduction time: 0.000 Final basis length: 17 Number of pairs: 56 Total pair setup time: 0.000 Max step: 2, time: 0.010 Max num entries matrix: 76 by 53 Max num rows matrix: 76 by 53 Approx mat cost: 8321.32, sym red cost: 338 Approx mat time: 0.000, sym red time: 0.000, total 0.000 Total symbolic reduction time: 0.000 Total column sort time: 0.000 Total row sort time: 0.000 Total matrix time: 0.010 Total new polys time: 0.000 Total queue update time: 0.000 Total Faugere F4 time: 0.010, real time: 0.004
1. Albrecht, M.R.: lattice-estimator (2023). https://github.com/malb/lattice- estimator/
5. Brakerski, Z., Gentry, C., Vaikuntanathan, V.: (Leveled) fully homomorphic encryption without bootstrapping. ACM Trans. Comput. Theory 6(3) (2014). https://doi.org/10.1145/2633600
7. Fan, J., Vercauteren, F.: Somewhat practical fully homomorphic encryption. Cryp- tology ePrint Archive, Paper 2012/144 (2012). https://eprint.iacr.org/2012/144
12. Halevi, S.: Comment under Issue #80 of HElib (2016). https://github.com/ homenc/HElib/issues/80#issuecomment-207448286
16. IBM: HElib (2023). https://github.com/homenc/HElib/
17. Kim, A., et al.: General bootstrapping approach for RLWE-based homomorphic encryption. IEEE Trans. Comput. 1–13 (2023). https://doi.org/10.1109/TC.2023. 3318405
9. Beyne, T.: Block cipher invariants as eigenvectors of correlation matrices. J. Cryp- tol. 33(3), 1156–1183 (2020) 30 X. Dong et al.
43. Jean, J., Nikoli´c, I., Peyrin, T., Seurin, Y.: Submission to CAESAR: Deoxys v1.41, October 2016. http://competitions.cr.yp.to/round3/deoxysv141.pdf
64. Zhao, B., Dong, X., Meier, W., Jia, K., Wang, G.: Generalized related-key rect- angle attacks on block ciphers with linear key schedule: applications to SKINNY and GIFT. Des. Codes Crypt. 88(6), 1103–1126 (2020). https://doi.org/10.1007/ s10623-020-00730-1
5. Atkinson, M.D.: Alternating trilinear forms and groups of exponent
6. J. Aust. Math. Soc. 16(1), 111–128 (1973) 608 G. Tang et al.
6. Babai, L.: Graph isomorphism in quasipolynomial time [extended abstract]. In: STOC 2016,  (2016)
7. Bai, S., et al.: Crystals-dilithium: algorithm speciﬁcations and supporting docu- mentation (version 3.1) (2021). https://pq-crystals.org/dilithium/data/dilithium- speciﬁcation-round3-20210208.pdf
9. Bardet, M., Faug`ere, J.C., Salvy, B., Yang, B.Y.: Asymptotic behaviour of the degree of regularity of semi-regular polynomial systems. In: Proceedings of the MEGA, vol. 5 (2005)
10. Berthomieu, J., Faug`ere, J.-C., Perret, L.: Polynomial-time algorithms for quadratic isomorphism of polynomials: the regular case. J. Complex. 31(4), 590– 616 (2015)
18. Brooksbank, P.A., Li, Y., Qiao, Y., Wilson, J.B.: Improved algorithms for alter- nating matrix space isometry: from theory to practice. In: 28th ESA 2020, pp. 26:1–26:15 (2020)
19. Brooksbank, P.A., Maglione, J., Wilson, J.B.: A fast isomorphism test for groups whose Lie algebra has genus
2. J. Algebra 473, 545–590 (2017)
20. Buss, J.F., Frandsen, G.S., Shallit, J.O.: The computational complexity of some problems of linear algebra. J. Comput. Syst. Sci. 58(3), 572–596 (1999)
24. Cohen, A.M., Helminck, A.G.: Trilinear alternating forms on a vector space of dimension
7. Commun. Algebra 16(1), 1–25 (1988)
30. Draisma, J., Shaw, R.: Some noteworthy alternating trilinear forms. J. Geom. 105(1), 167–176 (2013). https://doi.org/10.1007/s00022-013-0202-2
32. Erd˝os, P., R´enyi, A.: Asymmetric graphs. Acta Math. Hung. 14(3–4), 295–315 (1963)
33. Faug`ere, J.-C.: A new eﬃcient algorithm for computing gr¨obner bases without reduction to zero (F5). In: Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation,  (2002)
35. Faugere, J.-C., El Din, M.S., Spaenlehauer, P.-J.: On the complexity of the gener- alized minrank problem. J. Symb. Comput. 55, 30–58 (2013)
40. Fouque, P.-A., et al.: Falcon: fast-fourier lattice-based compact signatures over NTRU (speciﬁcation v1.2) (2020). https://falcon-sign.info/falcon.pdf
41. Goldreich, O., Micali, S., Wigderson, A.: Proofs that yield nothing but their validity for all languages in NP have zero-knowledge proof systems. J. ACM 38(3), 691–729 (1991)
43. Grigni, M., Schulman, L.J., Vazirani, M., Vazirani, U.V.: Quantum mechanical algorithms for the nonabelian hidden subgroup problem. Comb. 24(1), 137–154 (2004)
44. Grochow, J.A., Qiao, Y.: On the complexity of isomorphism problems for tensors, groups, and polynomials I: tensor isomorphism-completeness. In: ITCS 2021, pp. 31:1–31:19 (2021)
45. Grochow, J.A., Qiao, Y.: On p-group isomorphism: search-to-decision, counting-to- decision, and nilpotency class reductions via tensors. In: CCC 2021, pp. 16:1–16:38 (2021)
46. Grochow, J.A., Qiao, Y., Tang, G.: Average-case algorithms for testing isomor- phism of polynomials, algebras, and multilinear forms. In: STACS 2021, pp. 38:1– 38:17 (2021)
47. Grover, L.K.: A fast quantum mechanical algorithm for database search. In Pro- ceedings of the Twenty-eighth Annual ACM Symposium on Theory of Computing, (1996)
48. Hallgren, S., Moore, C., R¨otteler, M., Russell, A., Sen, P.: Limitations of quantum coset states for graph isomorphism. J. ACM 57(6):34:1–34:33 (2010)
49. H˚astad, J.: Tensor rank is NP-complete. J. Algorithms 11(4), 644–654 (1990)
50. Hora, J., Pudl´ak, P.: Classiﬁcation of 8-dimensional trilinear alternating forms over gf (2). Commun. Algebra 43(8), 3459–3471 (2015)
51. Ivanyos, G., Qiao, Y.: Algorithms based on *-algebras, and their applications to isomorphism of polynomials with one secret, group isomorphism, and polynomial identity testing. SIAM J. Comput. 48(3), 926–963 (2019)
56. K¨obler, J., Sch¨oning, U., Tor´an, J.: The graph isomorphism problem. Basel Birkh¨user (1993)
57. Kuperberg, G.: A subexponential-time quantum algorithm for the dihedral hidden subgroup problem. SIAM J. Comput. 35(1), 170–188 (2005)
58. Kuperberg, G.: Another subexponential-time quantum algorithm for the dihedral hidden subgroup problem. In: TQC 2013,  (2013) Signature Schemes from Trilinear Form Isomorphism 611
59. Li, Y., Qiao, Y.: Linear algebraic analogues of the graph isomorphism problem and the Erd˝os-R´enyi model. In: FOCS 2017,  IEEE Computer Society (2017)
61. Waterloo, Ontario: Maplesoft, a division of Waterloo Maple Inc., Maple (2020.2) (2020)
62. McKay, B.D.: Practical graph isomorphism. Congr. Numer. 30, 45–87 (1980)
63. McKay, B.D., Piperno, A.: Practical graph isomorphism II. J. Symb. Comput. 60, 94–112 (2014)
65. Midoune, N., Noui, L.: Trilinear alternating forms on a vector space of dimension 8 over a ﬁnite ﬁeld. Linear Multilinear Algebra 61(1), 15–21 (2013)
66. Montgomery, P.L.: Modular multiplication without trial division. Math. Comput. 44, 519–521 (1985)
67. Moore, C., Russell, A., Schulman, L.J.: The symmetric group deﬁes strong fourier sampling. SIAM J. Comput. 37(6), 1842–1864 (2008)
68. Moore, C., Russell, A., Vazirani, U.: A classical one-way function to confound quantum adversaries. arXiv preprint quant-ph/0701115 (2007)
70. O’Brien, E.A.: Isomorphism testing for p-groups. J. Symb. Comput. 17(2), 133–147 (1994)
73. Plantard, T.: Eﬃcient word size modular arithmetic. IEEE Trans. Emerg. Top. Comput. 9(3), 1506–1518 (2021)
74. Regev, O.: Quantum computation and lattice problems. SIAM J. Comput. 33(3), 738–760 (2004)
77. Sendrier, N.: Finding the permutation between equivalent linear codes: the support splitting algorithm. IEEE Trans. Inf. Theory 46(4), 1193–1203 (2000)
79. Shor, P.W.: Polynomial-time algorithms for prime factorization and discrete loga- rithms on a quantum computer. SIAM J. Comput. 26(5), 1484–1509 (1997)
81. Wilson, J.B.: Decomposing p-groups via Jordan algebras. J. Algebra 322(8), 2642– 2679 (2009)
82. Wright, E.M.: Graphs on unlabelled nodes with a given number of edges. Acta Math. 126(1), 1–9 (1971)
[18] (and hence n-party MPC with unconditional security with the same threshold for corruption is feasible [3,34]). We leave the problem of establishing the necessary and suﬃcient conditions on the correlations to realize broadcast/pseudo-signature for more than three parties as a fascinating open question. 1.1 Problem Formulation We consider a network consisting of three parties, P1, P2, and P3. The par- ties are connected by pairwise secure channels; we assume that the network is Complete Characterization of Broadcast from Correlations 565 synchronous, i.e., each party can recognize who should communicate next based on a common clock. As we mentioned, it is impossible to realize broadcast or pseudo- signatures from scratch if one among the three parties may be malicious. We assume that P1, P2, and P3 observe random variables (Xi)i∈[n], (Yi)i∈[n], (Zi)i∈[n], respectively, where [n] = {1, 2, . . . , n}, such that the triples (Xi, Yi, Zi)i∈[n], are independent and identically distributed (i.i.d.) according to a known distribution PXY Z. Broadcast. In a broadcast protocol, the sender P1 has a message b ∈{0, 1} it wants to convey to the other parties. The parties communicate interactively over the pairwise secure channels. In each round of communication, the com- municating party computes the message it sends based on its observations (i.e., parts of the correlation it observes), its transcript so far, and its private random- ness. At the end of the protocol, the receivers P2 and P3 output b2 ∈{0, 1} and b3 ∈{0, 1}, respectively. We say that a protocol is an ε-secure implementation of broadcast if the following two conditions are satisﬁed: – Correctness: When the sender P1 is honest with input b ∈{0, 1}, then all the honest receivers output b with probability at least 1 −ε; – Agreement: When both the receivers P2 and P3 are honest, they output the same value b2 = b3 with probability at least 1 −ε. We are interested in the necessary and suﬃcient condition on the distribution PXY Z of the correlation such that an ε-secure implementation of broadcast exists for an arbitrary ε > 0 and suﬃciently many copies n of the correlation. Pseudo-signature. In a pseudo-signature (PS) protocol with transfer path P1 →P2 →P3, the sender P1 has an input message b ∈{0, 1}, and the protocol consists of two phases, the signing phase and the transfer phase. In the signing phase, after some prescribed rounds of communication over the pairwise secure channels, the intermediate party P2 outputs b2 ∈{0, 1, ⊥}, where the symbol ⊥ indicates that P2 rejects the message sent by P1; the protocol proceeds to the transfer phase only when P2 does not reject in the signing phase. In the transfer phase, after some prescribed rounds of communication over the pairwise secure channels, the receiver P3 outputs b3 ∈{0, 1, ⊥}, where the symbol ⊥indicates that P3 rejects the message transferred by P2. We say that a protocol is an ε- secure implementation of pseudo-signature with transfer path P1 →P2 →P3 if the following four conditions are satisﬁed: – Correctness: If P1 and P2 are honest, then b2 = b with probability at least 1 −ε; – Unforgeability: If P1 and P3 are honest, then the probability of the event b3 /∈{b, ⊥} is less than ε; – Transferability: If P2 and P3 are honest, then the probability of the event (b2 ̸= ⊥) ∧(b3 ̸= b2) is less than ε; 566 V. Narayanan et al. – Secrecy: If P1 and P2 are honest, then the view of P3 in the signing phase is almost independent of the message b, i.e., the conditional distribution of P3’s view in the signing phase given b = 0 and b = 1 are close to each other in total variation distance1. We are interested in the necessary and suﬃcient condition on PXY Z such that an ε-secure pseudo-signature protocol with transfer path P1 →P2 →P3 exists for an arbitrary ε > 0 and suﬃciently large n. Relation Between Broadcast and Pseudo-signature. Broadcast and pseudo-signature are closely related. If a pseudo-signature protocol with either transfer path P1 →P2 →P3 or P1 →P3 →P2 is available, we can construct a secure implementation of broadcast with sender P1; e.g., see [16,32]2. Thanks to this result, a construction for pseudo-signature implies a construction for broad- cast, and an impossibility result for broadcast implies an impossibility result for pseudo-signature. Thus, we focus on constructions of pseudo-signatures and impossibility results for broadcast in this paper. The conditions on correlations under which pseudo-signature with transfer path P1 →P2 →P3 is feasible and broadcast with sender P1 is feasible turn out to be same giving us a complete characterization. 1.2 Related Work The problem of the broadcast was introduced in [24], where the necessary and suﬃcient condition for feasibility of broadcast was established. An alternative proof for the impossibility part was proposed in [13]. This argument has been widely used for proving impossibility results in distributed computing; e.g., see [6,15]. Many impossibility results on distributed computing have been derived using variants of this argument. The concept of the pseudo-signature was introduced in [32]; see also
[4] for an earlier attempt at introducing an information theoretic version of digital signature. They proposed a pseudo-signature protocol for a one bit message. More eﬃcient constructions based on bivariate polynomials were introduced in
[21] (see also [22]). The problem of implementing broadcast and pseudo-signature from corre- lated random variables was studied in [19]; this problem was motivated by an implementation of broadcast from measurement outcomes of quantum entangle- ment [14]. The minimum requirement for realizing broadcast was studied in [15]; for instance, the global broadcast among all the parties can be constructed from the three party broadcast as long as honest majority is satisﬁed [18]. 1 Our construction provides a protocol with perfect secrecy, while we prove our impos- sibility results without making use of the secrecy condition. Thus, the secrecy con- dition does not aﬀect the characterization. 2 On the other hand, if broadcast protocols with each party as sender is available, a pseudo-signature protocol, also known as an information checking protocol, can be constructed [7]. Complete Characterization of Broadcast from Correlations 567 1.3 Main Contributions and Results The main technical contributions of this paper are three-fold: (i) We give a construction for pseudo-signature from correlations (Theorem 5) which considerably expands the class of correlations for which it was known to be feasible. As we show, this construction, when combined with (ii) below, fully characterizes the class of feasible correlations which was an open problem [38, Section 18.7]. (ii) Given a pseudo-signature protocol with transfer path P1 →P3 →P2, we construct a pseudo-signature protocol with transfer path P1 →P2 →P3 (Theorem 6); an observation which is new to the best of our knowledge. (iii) We prove an impossibility for broadcast (which implies tight results for pseudo-signatures and broadcast) by generalizing the well-known technique of Fischer, Lynch, and Merritt
[13] to our case which has a setup in the form of correlations at the parties (Theorem 7). We believe this may be of more general interest. Using these we precisely characterize the class of correlations on which pseudo- signatures (Theorem 8) and broadcast (Theorem 9) can be based. As mentioned earlier, this class is the same for broadcast from sender P1 and for pseudo- signatures with either of the transfer paths which start with P1. We also pro- vide characterizations of the correlations under which pseudo-signature can be obtained when there is limited connectivity/directionality of links between the parties (Theorems 10–12)3. 1.4 Technical Overview Pseudo-signature from Correlations. Attempts at altering a random vari- able X may leave a statistical trace that a party who holds a correlated random variable Y may be able to detect – this observation forms the basis of building a pseudo-signature protocol from correlation. The party with Y can only hope to detect anomalies in those parts of X which non-trivially depend on Y . For instance, if two symbols x and x′ satisfy PY |X(·|x) = PY |X(·|x′), then a party observing Y cannot detect the swapping of x and x′. To account for this, fol- lowing [19], let us deﬁne X  Y as the maximal part of X which non-trivially depends on Y (in statistics, this is known as the minimal suﬃcient statistic for Y given X). Deﬁnition 1 (Minimal suﬃcient statistics). For a pair of random variables X, Y with joint distribution PXY , consider the partition of the alphabet X of X induced by the following equivalence relation: x ∼x′ if PY |X(y|x) = PY |X(y|x′), ∀y. We deﬁne ψXY to be the function which maps the elements in X to their cell (i.e., part) in the above partition, and we deﬁne X  Y def = ψXY (X). 3 A similar question for broadcast turns out to be trivial. 568 V. Narayanan et al. Notice that X  Y is a random variable which is a function of X alone, where the function (ψXY ) is deﬁned in terms of the distribution PXY . Fitzi, Wolf, and Wullschleger
[19] constructed a pseudo-signature protocol for transfer path P1 →P2 →P3 from n i.i.d. copies of a correlation X, Y, Z observed at parties P1, P2, P3, respectively. The sender P1 attaches copies of X  Y as the signature (the ﬁrst n/2 copies for message bit 0 and the second n/2 for message bit 1). As foreshadowed, P2, who holds the copies of Y , may detect any signiﬁcant anomalies in the signature (with high conﬁdence for suﬃciently large n; see Lemma 1). They showed that their protocol is secure as long as the simulatability condition4 X  Y ←→Y ←→Z (1) does not hold. Heuristically, (1) says that P2 can forge P1’s signature X  Y using Y in a manner undetectable by P3 relying on its observations Z. Furthermore, it was claimed in
[19] that when X  Y ←→Y ←→Z and X  Z ←→Z ←→Y hold, then pseudo-signature with either of the transfer paths in which P1 is the sender (i.e., P1 →P2 →P3 or P1 →P3 →P2) is impossible to build based on (X, Y, Z). However, there is a gap in the proof of [19, Theorem 3]5, and a pseudo-signature can be implemented even if both these Markov chains hold. In essence, these simulatability conditions do not account for the fact that P2 and P3 may eﬀectively “upgrade” their observations by communicating with the other parties even if they do not trust the other parties. We demonstrate diﬀerent possible ways in which this can be accomplished using a few examples; these examples also serve as counterexamples to [19, Theorem 3] and build up intuition for our construction. Example 1 (Upgrading P3’s observation by communication from P1). Let us consider a correlation induced by Rabin’s oblivious transfer. Suppose that X is uniformly distributed on {0, 1}, and Y = Z such that it is X with probability 1 2 and the erasure symbol e with probability 1
2. Then, since Y = Z, this correlation satisﬁes both X  Y ←→Y ←→Z and X  Z ←→Z ←→Y . However, we can implement a pseudo-signature protocol from this correlation as follows. Let (Xi, Yi, Zi)i∈[n] be i.i.d. observations distributed according to PXY Z.
1. To send message b ∈{0, 1}, P1 sends b and ( ˜Xi)i∈Tb = (Xi)i∈Tb to P2, where Tb = {i : bn 2 + 1 ≤i ≤(b+1)n 2 }.
2. P2 rejects if Yi /∈{Xi, e} for some i ∈Tb. Otherwise, P2 accepts b.
3. P1 sends ( ˆXi)i∈[n] = (Xi)i∈[n] to P3.
4. To transfer a message b it accepted, P2 sends ˆb = b and ( ˘Xi)i∈Tˆb = ( ˜Xi)i∈Tb to P3. 4 We write “the Markov chain U ←→V ←→W holds,” or simply “U ←→V ←→ W” to mean U and W are conditionally independent conditioned on V . 5 It turns out that by considering restricted connectivity, speciﬁcally, when there is no link between P1 and P3 and the link from P2 to P3 is unidirectional, it can be shown that pseudo-signature from (X, Y, Z) is possible (if and) only if X  Y ←→ Y ←→Z is not a Markov chain (see Theorem 12). Complete Characterization of Broadcast from Correlations 569
5. P3 accepts ˆb if any one of the following holds: (i) Zi /∈{ ˆXi, e} for some i ∈[n]; and (ii) |{i ∈Tˆb : ˘Xi ̸= ˆXi}| ≤nδ for a parameter δ >
0. Otherwise, P3 rejects. Clearly, the above protocol is perfectly correct. To verify transferability (security against P1), notice that, to be successful, a corrupt P1 must convince P3 to reject in step
5. while ensuring that P2 accepts in step 2.. In order for this, P1’s transmissions ( ˘Xi)i∈Tb and ( ˆXi)i∈Tb to P2 and P3, respectively, must disagree in more than nδ locations. However, unless the observations of P2 and P3 (i.e., Yi = Zi) are not e in all such locations, the attack will not succeed (since either P2 will reject in step
2. or P3 will accept the bit P2 transfers in step 5.). Hence, the chance of success for P1 is at most 2−δn. To see unforgeability (security against P2), notice that a successful attack by P2 requires it to guess Xi for all i ∈T1−b where Yi = e such that the number of incorrect guesses is no more than nδ. Since for each i ∈T1−b, the probability of Yi = e is 1/2 and P2 has even odds of guessing correctly, the probability of a successful attack is 2−Ω(n) for δ < 1/8 (see, e.g., [29, Theorem 4.5]). ▷ In the above example, P3’s observation is eﬀectively upgraded from Z to (X, Z) using communication from P1 in step 3.. Note that (in step 5.) P3 veriﬁes this communication from P1; if the veriﬁcation fails, P3 accepts any message P2 transfers, and if the veriﬁcation succeeds, with overwhelming probability P1 has not lied on more than a small fraction of locations. In general, P3 can only (statistically) verify the parts of X which non-trivially depend on Z, namely X  Z (which happens to be X in this example). Thus, following the intuition in the example, we may build6 a pseudo-signature protocol from correlations (X, Y, Z) whenever the following condition (which is stronger compared to (1)) does not hold: X  Y ←→Y ←→(Z, X  Z). (2) It turns out that we may further expand the class of feasible correlations by upgrading P3’s observation via communication from both P1 and P2 (also see [30, Example 3 in
[ARU14] Ambainis, A., Rosmanis, A., Unruh, D.: Quantum attacks on classical proof systems: the hardness of quantum rewinding. In: 55th FOCS,  (2014)
[BGI+12] Barak, B., et al.: On the (IM) possibility of obfuscating programs. J. ACM 59(2), 6:1–6:48 (2012)
[CMSZ21] Chiesa, A., Ma, F., Spooner, N., Zhandry, M.: Post-quantum succinct arguments: breaking the quantum rewinding barrier. In: FOCS 2021 (2021)
[Wat09] Watrous, J.: Zero-knowledge against quantum attacks. SIAM J. Comput. 39(1), 25–58 (2009)
[Zha12a] Zhandry, M.: How to construct quantum random functions. In: 53rd FOCS,  (2012)
3. Bernstein, D.J., De Feo, L., Leroux, A., Smith, B.: Faster computation of isoge- nies of large prime degree. In: Open Book Series, Proceedings of the Fourteenth Algorithmic Number Theory Symposium - ANTS XIV 4.1,  (2020)
6. Cornacchia, G.: Su di un metodo per la risoluzione in numeri interi dell’equazione n h=0 Chxn−hyh = P. Giornale di matematiche di Battaglini 46, 33–90 (1908)
17. Hazay, C., Lindell, Y.: Eﬃcient Secure Two-Party Protocols: Techniques and Con- structions. 1st. Springer, Berlin (2010). ISBN: 3642143024
19. Kani, E.: The number of curves of genus two with elliptic diﬀerentials. J. f¨ur die reine und angewandte Mathematik 485, 93–122 (1997). https://doi.org/10.1515/ crll.1997.485.93
20. Kohel, D., Lauter, K., Petit, C., Tignol, J.-P.: On the quaternion - isogeny path problem. LMS J. Comput. Math. 17 (2014). https://doi.org/10.1112/ S1461157014000151
21. de Lagrange, J. L.: D´emonstration d’un th´eoreme d’arithm´etique. In: Nouveau M´emoire de l’Acad´emie Royale des Sciences de Berlin,  (1770)
24. Lubicz, D., Robert, D.: Computing isogenies between abelian varieties. Compos. Math. 148(5), 1483–1515 (2012). https://doi.org/10.1112/S0010437X12000243
25. Lubicz, D., Robert, D.: Computing separable isogenies in quasi-optimal time. LMS J. Comput. Math. 18(1), 98–216 (2015). https://doi.org/10.1112/ S146115701400045X
26. Lubicz, D., Robert, D.: Fast change of level and applications to isogenies. 9, 7 (2023). https://doi.org/10.1007/s40993-022-00407-9
28. PARI/GP version 2.13.4. http://pari.math.u-bordeaux.fr/. The PARI Group. Univ. Bordeaux (2022)
30. Pollack, P., Trevi˜no, E.: Finding the four squares in lagrange’s theorem. Integers 18A, A15 (2018)
31. Rabin, J.O., Shallit, M.O.: Randomized algorithms in number theory. Com- mun. Pure Appl. Math. 39(S1), S239–S256 (1986). https://doi.org/10.1002/cpa. 3160390713
35. Rouse, J., Thompson, K.: Quaternary quadratic forms with prime discriminant (2022). arXiv: 2206.00412 [math.NT]
38. V´elu, J.: Isog´enies entre courbes elliptiques. In: Comptes-rendus de l’Acad´emie des Sciences, vol. 273, , July 1971. https://gallica.bnf.fr
39. Venturi, D., Villani, A.: Zero-knowledge proofs and applications, May 2015. http:// danieleventuri.altervista.org/ﬁles/zeroknowledge.pdf
40. Voight, J.: Quaternion algebras. v.0.9.23, August 2020. https://math.dartmouth. edu/∼jvoight/quat.html
41. Wesolowski, B.: The supersingular isogeny path and endomorphism ring problems are equivalent. In: FOCS 2021 - 62nd Annual IEEE Symposium on Foundations of Computer Science. Denver, Colorado, United States, February 2022. https://hal. archives-ouvertes.fr/hal-03340899
15. Canetti, R., Lindell, Y., Ostrovsky, R., Sahai, A.: Universally composable two- party and multi-party secure computation. In: 34th ACM STOC, ACM Press, May 2002. https://doi.org/10.1145/509907.509980
16. Chor, B., Goldwasser, S., Micali, S., Awerbuch, B.: Veriﬁable secret sharing and achieving simultaneity in the presence of faults. In: 26th Annual Symposium on Foundations of Computer Science (SFCS 1985),  IEEE (1985)
23. Gennaro, R., Goldfeder, S.: Fast multiparty threshold ECDSA with fast trustless setup. In: Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security,  (2018)
25. Gentry, C., Halevi, S., Lyubashevsky, V.: Practical non-interactive publicly veri- ﬁable secret sharing with thousands of parties. https://eprint.iacr.org/2021/1397 (2021) 486 C. Gentry et al.
28. Goldreich, O., Micali, S., Wigderson, A.: Proofs that yield nothing but their validity or all languages in np have zero-knowledge proof systems. J. ACM (JACM) 38(3), 690–728 (1991)
34. Johnson, W.B., Lindenstrauss, J.: Extensions of Lipschitz mappings into a Hilbert space
26. Contemporary mathematics 26 (1984)
43. Melchor, C.A., Barrier, J., Fousse, L., Killijian, M.O.: XPIR: private information retrieval for everyone. Proc. Privacy Enhancing Technol. 2016, 155–174 (2016)
53. Sion, R., Carbunar, B.: On the computational practicality of private information retrieval. In: Proceedings of the Network and Distributed Systems Security Sym- posium,  Internet Society (2007)
55. Wu, T.Y., Tseng, Y.M.: A pairing-based publicly veriﬁable secret sharing scheme. J. Syst. Sci. Complex. 24(1), 186–194 (2011)
1. Beaver, D.: Eﬃcient multiparty protocols using circuit randomization, (1992). https://doi.org/10.1007/3-540-46766-1_34
2. Beck, G., Goel, A., Jain, A., Kaptchuk, G.: Order-C secure multiparty computation for highly repetitive circuits,  (2021). https://doi.org/10.1007/978-3- 030-77886-6_23
3. Ben-Efraim, A., Nielsen, M., Omri, E.: Turbospeedz: double your online SPDZ! Improving SPDZ using function dependent preprocessing,  (2019). https://doi.org/10.1007/978-3-030-21568-2_26
5. Bendlin, R., Damgård, I., Orlandi, C., Zakarias, S.: Semi-homomorphic encryption and multiparty computation,  (2011). https://doi.org/10.1007/978-3- 642-20465-4_11
6. Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., Ishai, Y.: Zero-knowledge proofs on secret-shared data via fully linear PCPs,  (2019). https://doi. org/10.1007/978-3-030-26954-8_3
7. Boyle, E., Gilboa, N., Ishai, Y., Nof, A.: Eﬃcient fully secure computation via distributed zero-knowledge proofs,  (2020). https://doi.org/10.1007/ 978-3-030-64840-4_9
9. Chida, K., et al.: Fast large-scale honest-majority MPC for malicious adversaries, (2018). https://doi.org/10.1007/978-3-319-96878-0_2
10. Couteau, G.: A note on the communication complexity of multiparty computation in the correlated randomness model,  (2019). https://doi.org/10.1007/ 978-3-030-17656-3_17
12. Damgård, I., Keller, M., Larraia, E., Pastro, V., Scholl, P., Smart, N.P.: Practical covertly secure MPC for dishonest majority - or: Breaking the SPDZ limits,  (2013). https://doi.org/10.1007/978-3-642-40203-6_1
13. Damgård, I., Nielsen, J.B.: Scalable and unconditionally secure multiparty compu- tation,  (2007). https://doi.org/10.1007/978-3-540-74143-5_32
14. Damgård, I., Pastro, V., Smart, N.P., Zakarias, S.: Multiparty computation from somewhat homomorphic encryption,  (2012). https://doi.org/10.1007/ 978-3-642-32009-5_38
15. Escudero, D., Goyal, V., Polychroniadou, A., Song, Y.: TurboPack: honest majority MPC with constant online communication,  (2022). https://doi.org/10. 1145/3548606.3560633
16. Franklin, M.K., Yung, M.: Communication complexity of secure computation (extended abstract),  (1992). https://doi.org/10.1145/129712.129780 250 D. Escudero et al.
17. Genkin, D., Ishai, Y., Polychroniadou, A.: Eﬃcient multi-party computation: from passive to active security via secure SIMD circuits,  (2015). https:// doi.org/10.1007/978-3-662-48000-7_35
18. Genkin, D., Ishai, Y., Prabhakaran, M.M., Sahai, A., Tromer, E.: Circuits resilient to additive attacks with applications to secure computation. In: Proceedings of the Forty-sixth Annual ACM Symposium on Theory of Computing, STOC 2014, ACM, New York, NY, USA (2014). https://doi.org/10.1145/2591796. 2591861
20. Goyal, V., Li, H., Ostrovsky, R., Polychroniadou, A., Song, Y.: ATLAS: eﬃcient and scalable MPC in the honest majority setting,  (2021). https://doi. org/10.1007/978-3-030-84245-1_9
21. Goyal, V., Polychroniadou, A., Song, Y.: Unconditional communication-eﬃcient MPC via hall’s marriage theorem,  (2021). https://doi.org/10.1007/ 978-3-030-84245-1_10
22. Goyal, V., Polychroniadou, A., Song, Y.: Sharing transformation and dishonest majority MPC with packed secret sharing,  (2022). https://doi.org/10. 1007/978-3-031-15985-5_1
23. Goyal, V., Song, Y.: Malicious security comes free in honest-majority MPC. Cryp- tology ePrint Archive, Report 2020/134 (2020). https://eprint.iacr.org/2020/134
24. Lindell, Y., Nof, A.: A framework for constructing fast MPC over arithmetic circuits with malicious adversaries and an honest-majority,  (2017). https://doi.org/10.1145/3133956.3133999
25. Rachuri, R., Scholl, P.: Le mans: Dynamic and ﬂuid MPC for dishonest majority, (2022). https://doi.org/10.1007/978-3-031-15802-5_25
26. Shamir, A.: How to share a secret. Commun. ACM 22(11), 612–613 (1979). https:// doi.org/10.1145/359168.359176
21. Coda. https://codaprotocol.com/ (2022)
26. Fleischhacker, N., Jager, T., Schröder, D.: On tight security proofs for Schnorr signatures. J. Crypt. 32(2), 566–599 (2019)
29. Ganesh, C., Khoshakhlagh, H., Kohlweiss, M., Nitulescu, A., Zając, M.: What makes ﬁat-shamir zksnarks (updatable SRS) simulation extractable? In: SCN (2022)
34. Goldwasser, S., Micali, S., Rackoﬀ, C.: The knowledge complexity of interactive proof-systems (extended abstract). In: 17th ACM STOC,  ACM Press (May 1985)
36. Grin: a minimal implementation of mimblewimble. https://github.com/ mimblewimble/grin (2022)
51. Polygon. https://polygon.technology/ (2022)
52. Sahai, A.: Non-malleable non-interactive zero knowledge and adaptive chosen- ciphertext security. In: 40th FOCS,  IEEE Computer Society Press (Oct 1999)
53. Scroll. https://scroll.io/ (2022)
56. Starkware. https://starkware.co/ (2022) 562 Q. Dao and P. Grubbs
62. ZKProofs Standards. https://zkproof.org/ (2022)
1. Run A, answering its classical queries using R and its quantum queries using P, stopping immediately before its (j + 1)st classical query. Let Tj = (x1, y1, b1), . . . , (xj, yj, bj) be the ordered list of classical queries/answers.
2. For the remainder of the execution of A, answer its classical queries using Ek[P] and its quantum queries using PTj,k. We can compactly represent Hj as the experiment in which A’s queries are answered using the oracle sequence P, R, P, · · · , R, P,    j classical queries Ek[P], PTj,k, · · · , Ek[P], PTj,k    qE−j classical queries . Each appearance of R or Ek[P] indicates a single classical query. Each appear- ance of P or PTj,k indicates a stage during which A makes multiple (quantum) queries to that oracle but no queries to its classical oracle. Observe that H0 corresponds to the execution of A in the real world, i.e., AEk[P ],P , and that HqE is the execution of A in the ideal world, i.e., AR,P . For j = 0, . . . , qE −1, we introduce additional experiments H′ j: Experiment H′ j. Sample R, P ←Pn and k ←D. Then:
1. Run A, answering its classical queries using R and its quantum queries using P, stopping immediately after its (j + 1)st classical query. Let Tj+1 = (x1, y1, b1), . . . , (xj+1, yj+1, bj+1) be the ordered list indicating A’s classical queries/answers. 468 G. Alagic et al.
2. For the remainder of the execution of A, answer its classical queries using Ek[P] and its quantum queries using PTj+1,k. Thus, H′ j corresponds to running A using the oracle sequence P, R, P, · · · , R, P,    j classical queries R, PTj+1,k, Ek[P], PTj+1,k · · · , Ek[P], PTj+1,k    qE−j−1 classical queries . In Lemmas 6 and 7, we establish bounds on the distinguishability of H′ j and Hj+1, as well as Hj and H′ j. For 0 ≤j < qE these give: Pr[A(H′ j) = 1] −Pr[A(Hj+1) = 1]  ≤2 · qP,j+1 ·  2 · (j + 1) 2n . Pr[A(Hj) = 1] −Pr[A(H′ j) = 1]  ≤8 · qP 2n + 2qE · 2−n Using the above, we have |Pr[A(H0) = 1] −Pr[A(HqE) = 1]| ≤ qE−1  j=0  8 · qP 2n + 2qE · 2−n + 2 · qP,j+1  2 · (j + 1) 2n  ≤2q2 E · 2−n + qE−1  j=0  8 · qP 2n + 2 · qP,j+1  2qE 2n  ≤2q2 E · 2−n + 2−n/2 ·  8qE √qP + 2 · qP  2qE  . We now simplify the bound further. If qP = 0, then Ek and R are perfectly indistinguishable and the theorem holds; thus, we may assume qP ≥1. We can also assume qE < 2n/2 since otherwise the bound is larger than
1. Under these assumptions, we have q2 E · 2−n ≤qE · 2−n/2 ≤qE√qP · 2−n/2 and so 2q2 E · 2−n + 2−n/2  8qE √qP + 2qP  2qE  ≤2 · qE √qP · 2−n/2 + 2−n/2  8qE √qP + 2qP  2qE  ≤10 · 2−n/2 (qE √qP + qP √qE) , as claimed. ⊓⊔ To complete the proof of Theorem 3, we now show that H′ j is indistinguish- able from to Hj+1 and Hj is indistinguishable from H′ j. Lemma
6. For j = 0, . . . , qE −1, Pr[A(H′ j) = 1] −Pr[A(Hj+1) = 1]| ≤2 · qP,j+1  2 · (j + 1)/2n , where qP,j+1 is the expected number of queries A makes to P in the (j + 1)st stage in the ideal world (i.e., in HqE.) Post-Quantum Security of the Even-Mansour Cipher 469 Proof. Recall we can write the oracle sequences deﬁned by H′ j and Hj+1 as H′ j : P, R, P, · · · , R, P, R, PTj+1,k, Ek[P], PTj+1,k, · · · , Ek[P], PTj+1,k Hj+1 : P, R, P, · · · , R, P    j classical queries , R, P, Ek[P], PTj+1,k, · · · , Ek[P], PTj+1,k    qE−j−1 classical queries . Let A be a distinguisher between H′ j and Hj+1. We construct from A a distin- guisher D for the blinding experiment from Lemma 3: Phase 1: D samples P, R ←Pn. It then runs A, answering its quantum queries using P and its classical queries using R, until after it responds to A’s (j + 1)st classical query. Let Tj+1 = (x1, y1, b1), . . . , (xj+1, yj+1, bj+1) be the list of classical queries/answers. D deﬁnes F(t, x) := P t(x) for t ∈{1, −1}. It also deﬁnes the following randomized algorithm B: sample k ←D and then compute the set B of input/output pairs to be reprogrammed so that F (B)(t, x) = P t Tj+1,k(x) for all t, x. Phase 2: B is run to generate B, and D is given quantum access to an oracle Fb. D resumes running A, answering its quantum queries using P t = Fb(t, ·). Phase 2 ends when A makes its next (i.e., (j + 2)nd) classical query. Phase 3: D is given the randomness used by B to generate k. It resumes run- ning A, answering its classical queries using Ek[P] and its quantum queries using PTj+1,k. Finally, it outputs whatever A outputs. Observe that D is a valid distinguisher for the reprogramming experiment of Lemma
3. It is immediate that if b = 0 (i.e., D’s oracle in phase 2 is F0 = F), then A’s output is identically distributed to its output in Hj+1, whereas if b = 1 (i.e., D’s oracle in phase 2 is F1 = F (B)), then A’s output is identically distributed to its output in H′ j. It follows that | Pr[A(H′ j) = 1] −Pr[A(Hj+1) = 1]| is equal to the distinguishing advantage of D in the reprogramming experiment. To bound this quantity using Lemma 3, we bound the reprogramming probability ϵ and the expected number of queries made by D in phase 2 (when F = F0.) The reprogramming probability ϵ can be bounded using the deﬁnition of PTj+1,k and the fact that F (B)(t, x) = P t Tj+1,k. Fixing P and Tj+1, the probability that any given (t, x) is reprogrammed is at most the probability (over k) that it is in the set  (1, xi ⊕k1), (1, P −1(yi ⊕k2)), (−1, P(xi ⊕k1)), (−1, yi ⊕k2) j+1 i=1 . Taking a union bound and using the fact that the marginal distributions of k1 and k2 are each uniform, we get ϵ ≤2(j + 1)/2n. The expected number of queries made by D in Phase 2 when F = F0 is equal to the expected number of queries made by A in its (j + 1)st stage in Hj+1. Since Hj+1 and HqE are identical until after the (j +1)st stage is complete, this is precisely qP,j+1. ⊓⊔ Lemma
7. For j = 0, . . . , qE, Pr[A(Hj) = 1] −Pr[A(H′ j) = 1]  ≤8 · qP 2n + 2qE · 2−n. 470 G. Alagic et al. Proof. Recall that we can write the oracle sequences deﬁned by Hj and H′ j as Hj : P, R, P, · · · , R, P, Ek[P], PTj,k, Ek[P], PTj,k , · · · , Ek[P], PTj,k H′ j : P, R, P, · · · , R, P    j classical queries , R, PTj+1,k, Ek[P], PTj+1,k, · · · , Ek[P], PTj+1,k    qE−j−1 classical queries . Let A be a distinguisher between Hj and H′ j. We construct from A a distin- guisher D for the reprogramming experiment of Lemma 5: Phase 1: D is given quantum access to a permutation P. It samples R ←Pn and then runs A, answering its quantum queries with P and its classical queries with R (in the appropriate directions), until A submits its (j + 1)st classical query xj+1 in the forward direction2 (i.e., bj+1 = 0). Let Tj = (x1, y1, b1), · · · , (xj, yj, bj) be the list of classical queries/answers thus far. Phase 2: Now D receives s0, s1 ∈{0, 1}n and quantum oracle access to a per- mutation Pb. Then D sets k1 := s0 ⊕xj+1, chooses k2 ←D|k1 (where this represents the conditional distribution on k2 given k1), and sets k := (k1, k2). D continues running A, answering its remaining classical queries (including the (j + 1)st one) using Ek[Pb], and its remaining quantum queries using (Pb)Tj,k = ←− S Tj,Pb,k ◦−→ S Tj,Pb,k ◦Pb . Finally, D outputs whatever A outputs. Note that although D makes additional queries to Pb in phase 2 (to determine Pb(x1⊕k1), . . . , Pb(xj ⊕k1)), the bound of Lemma 5 only depends on the number of quantum queries D makes in phase 1, which is at most qP . We now analyze the execution of D in the two cases of the game of Lemma 5: b = 0 (no reprogramming) and b = 1 (reprogramming). In both cases, P and R are independent, uniform permutations, and A is run with quantum oracle P and classical oracle R until it makes its (j + 1)st classical query; thus, through the end of phase 1, the above execution of A is consistent with both Hj and H′ j. At the start of phase 2, uniform s0, s1 ∈{0, 1}n are chosen. Since D sets k1 := s0 ⊕xj+1, the distribution of k1 is uniform and hence k is distributed according to D. The two cases (b = 0 and b = 1) now begin to diverge. Case b = 0 (No Reprogramming). In this case, A’s remaining classical queries (including its (j + 1)st classical query) are answered using Ek[P0] = Ek[P], and its remaining quantum queries are answered using (P0)Tj,k = PTj,k. The output of A is thus distributed identically to its output in Hj in this case. Case b = 1 (Reprogramming). In this case, we have Pb = P1 = P ◦swaps0,s1 = swapP (s0),P (s1) ◦P = swapP (xj+1⊕k1),P (s1) ◦P . (3) 2 We assume for simplicity that this query is in the forward direction, but the case where it is in the inverse direction can be handled entirely symmetrically (using the fact that the marginal distribution of k2 is uniform). The strings s0 and s1 are in that case replaced by Pb(s0) and Pb(s1). See
4. Refined estimation of the survival function (red, dash-dot line) com- pared to the experiments in [DP23b, §5] (green, full line) and the prediction with the standard independence assumption (blue, dashed line). (left) q = 3329, n = 60, T = 245, N = 5040 and w = 0.0320; (right) q = 3329, n = 80, T = 248, N = 89494 and w = 0.0376
8. Bogdanov, A., Rijmen, V.: Linear hulls with correlation zero and linear cryptanal- ysis of block ciphers. Des. Codes Crypt. 70(3), 369–383 (2012). https://doi.org/ 10.1007/s10623-012-9697-z
25. Knudsen, L.: Deal-a 128-bit block cipher. Complexity 258(2), 216 (1998)
26. Lai, X.: Higher order derivatives and diﬀerential cryptanalysis,  (1994). https://doi.org/10.1007/978-1-4615-2694-0 23
35. Perron, L., Furnon, V.: OR-Tools. https://developers.google.com/optimization/
47. Yang, D., Qi, W., Chen, H.: Impossible diﬀerential attacks on the SKINNY family of block ciphers. IET Inf. Secur. 11(6), 377–385 (2017). https://doi.org/10.1049/ iet-ifs.2016.0488
48. Zhang, Y., Cui, T., Wang, C.: Zero-correlation linear attack on reduced-round SKINNY. Frontiers of Comput. Sci. 17(174808 (2023)), 377–385 (2022). https:// doi.org/10.1007/s11704-022-2206-2
8. Chandy, K.M., Lamport, L.: Distributed snapshots: determining global states of distributed systems. ACM Trans. Comput. Syst. 3(1), 63–75 (1985)
10. Cohn-Gordon, K., Cremers, C.J.F., Garratt, L.: On post-compromise security. In: Hicks, M., Köpf, B. (eds.) CSF 2016 Computer Security Foundations Symposium, IEEE Computer Society Press (2016)
23. Lamport, L.: Time, clocks, and the ordering of events in a distributed system. Communications (1978)
25. Marson, G.A.: Real-World Aspects of Secure Channels: Fragmentation, Causality, and Forward Security. PhD thesis, Technische Universität (2017) 282 S. Chen and M. Fischlin
28. Perrin, T., Marlinspike, M.: The double ratchet algorithm (2016). https://signal. org/docs/speciﬁcations/doubleratchet/doubleratchet.pdf
32. Rösler, P., Mainka, C., Schwenk, J.: More is less: on the end-to-end security of group chats in Signal, WhatsApp, and Threema. In: EuroS&P,  IEEE (2018)
33. Scarlata, M.: Post-compromise security and TLS 1.3 session resumption (2020)
34. Strom, R.E., Yemini, S.: Optimistic recovery in distributed systems. ACM Trans. Comput. Syst. 3(3), 204–226 (1985)
5. Cand`es, E.J., Romberg, J., Tao, T.: Robust uncertainty principles: Exact signal reconstruction from highly incomplete frequency information. IEEE Trans. Inf. Theory 52(2), 489–509 (2006). https://doi.org/10.1109/TIT.2005.862083 576 N. Fleischhacker et al.
6. Cheon, J.H., Kim, M., Kim, M.: Optimized search-and-compute circuits and their application to query evaluation on encrypted data. IEEE Trans. Inf. Forens. Secur. 11(1), 188–199 (2016). https://doi.org/10.1109/TIFS.2015.2483486
9. Cooley, J.W., Tukey, J.W.: An algorithm for the machine calculation of complex Fourier series. Math. Comput. 19(90), 297–301 (1965)
11. Donoho, D.L.: Compressed sensing. IEEE Trans. Inf. Theory 52(4), 1289–1306 (2006). https://doi.org/10.1109/TIT.2006.871582
12. Gentry, C.: A Fully Homomorphic Encryption Scheme. Ph.D. thesis, Stanford, CA, USA (2009)
13. Gilbert, A., Indyk, P.: Sparse recovery using sparse matrices. Proc. IEEE 98(6), 937–947 (2010). https://doi.org/10.1109/JPROC.2010.2045092
14. Goodrich, M.T., Mitzenmacher, M.: Invertible bloom lookup tables. In: 49th Annual Allerton Conference on Communication, Control, and Computing (Aller- ton),  IEEE Computer Society Press (2011). https://doi.org/10.1109/ Allerton.2011.6120248
17. Klinc, D., Hazay, C., Jagmohan, A., Krawczyk, H., Rabin, T.: On compression of data encrypted with block ciphers. In: Storer, J.A., Marcellin, M.W. (eds.) DCC 2009: 19th Data Compression Conference.  IEEE Computer Society Press, Snowbird (2009). https://doi.org/10.1109/DCC.2009.71
21. de Prony, G.: Essai exp´erimental et analytique sur les lois de la dilatabilit´e des ﬂuides ´elastiques et sur celles de la force expansive de la vapeur de l’eau et de la vapeur de l’alcool `a diﬀ´erentes temp´eratures. J. l’´Ecole Polytech. 1(22), 24–76 (1795)
22. Rivest, R.L., Adleman, L., Dertouzos, M.L.: On data banks and privacy homomor- phisms. In: DeMillo, R.A., Lipton, R.J., Dobkin, D.P., Jones, A.K. (eds.) Founda- tions of Secure Computation,  Academic Press (1978)
23. Shanks, D.: Class number, a theory of factorization, and genera. In: Lewis, D.J. (ed.) 1969 Number Theory Institute. Proceedings of Symposia in Pure Mathemat- ics, vol. 20,  American Mathematical Society (1971)
24. Slepian, D., Wolf, J.: Noiseless coding of correlated information sources. IEEE Trans. Inf. Theory 19(4), 471–480 (1973). https://doi.org/10.1109/TIT.1973. 1055037
26. Nageler, M.: Automatic cryptanlysis of block ciphers: ﬁnding eﬃcient key-recovery attacks. Master’s thesis, Graz University of Technology (2022). https://doi.org/10. 3217/n8ehm-dgj71
29. Qiao, K., Hu, L., Sun, S.: Diﬀerential security evaluation of Simeck with dynamic key-guessing techniques. In: Camp, O., Furnell, S., Mori, P. (eds.) ICISSP 2016, SciTePress (2016)
37. Wang, N., Wang, X., Jia, K., Zhao, J.: Diﬀerential attacks on reduced SIMON ver- sions with dynamic key-guessing techniques. Sci. China Inf. Sci. 61(9), 098103:1– 098103:3 (2018)
38. Zhang, W., Bao, Z., Lin, D., Rijmen, V., Yang, B., Verbauwhede, I.: RECTANGLE: a bit-slice lightweight block cipher suitable for multiple platforms. Sci. China Inf. Sci. 58(12), 1–15 (2015)
7. Bardet, M., Faug´ere, J.C., Salvy, B., Yang, B.Y.: Asymptotic behaviour of the degree of regularity of semi-regular polynomial systems. In: Proceedings of MEGA, vol. 5 (2005)
12. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: The KECCAK reference (2011). https://keccak.team/ﬁles/Keccak-reference-3.0.pdf
18. Cox, D., Little, J., O’Shea, D.: Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media (2013)
30. Faug´ere, J.C.: A new eﬃcient algorithm for computing Gr¨obner bases (F4). J. Pure Appl. Algebra 139(1–3), 61–88 (1999)
34. Grassi, L., Øygarden, M., Schofnegger, M., Walch, R.: From farfalle to megafono via ciminion: The PRF hydra for MPC applications (2022). https://eprint.iacr. org/2022/342
39. Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge from secure multiparty computation. In: Johnson, D.S., Feige, U. (eds.) 39th ACM STOC,  ACM Press (Jun 2007). https://doi.org/10.1145/1250790.1250794
47. Shamir, A.: How to share a secret. Commun. ACM 22(11), 612–613 (1979). https:// doi.org/10.1145/359168.359176
8. Bartusek, J., Ishai, Y., Jain, A., Ma, F., Sahai, A., Zhandry, M.: Aﬃne determinant programs: a framework for obfuscation and witness encryption. In: 11th ITCS, pp. 82:1–82:39. LIPIcs (2020)
11. Bitansky N., Vaikuntanathan V.: Indistinguishability obfuscation from functional encryption. In: 56th FOCS,  IEEE (2015)
21. Garg, S., Gentry, C., Halevi, S., Raykova, M., Sahai, A., Waters, B.: Candidate indistinguishability obfuscation and functional encryption for all circuits. In: 54th FOCS,  IEEE (2013)
23. Gay, R., Pass, R.: Indistinguishability obfuscation from circular security. In: 53rd STOC,  ACM (2021)
27. Ishai, Y., Kushilevitz, E.: Private simultaneous messages protocols with applica- tions. In: 5th ISTCS,  IEEE (1997)
30. Jain, A., Lin, H., Sahai, A.: Indistinguishability obfuscation from well-founded assumptions. In: 53rd STOC,  ACM (2021)
32. Koppula, V., Lewko, A.B., Waters, B.: Indistinguishability obfuscation for turing machines with unbounded memory. In: 47th STOC,  ACM (2015)
36. Lin, H., Vaikuntanathan, V.: Indistinguishability obfuscation from DDH-like assumptions on constant-degree graded encodings. In: 57th FOCS,  IEEE (2016)
38. Sahai, A., Waters, B.: How to use indistinguishability obfuscation: deniable encryp- tion, and more. In: 46th STOC,  ACM (2014)
6. Asharov, G., Segev, G.: Limits on the power of indistinguishability obfuscation and functional encryption. SIAM J. Comput. 45(6), 2117–2176 (2016). https:// doi.org/10.1137/15M1034064 530 X. Mao et al.
10. Bitansky, N., Kalai, Y.T., Paneth, O.: Multi-collision resistance: a paradigm for keyless hash functions. In: Proceedings of the 50th Annual ACM SIGACT Sym- posium on Theory of Computing,  (2018). https://doi.org/10.1145/ 3188745.3188870
16. Haitner, I., Mazor, N., Silbak, J.: Incompressibility and next-block pseudoentropy. 14th Innovations in Theoretical Computer Science (2023)
17. Haitner, I., Reingold, O., Vadhan, S.: Eﬃciency improvements in constructing pseu- dorandom generators from one-way functions. SIAM J. Comput. 42(3), 1405–1430 (2013). https://doi.org/10.1137/100814421
18. Haitner, I., Reingold, O., Vadhan, S., Wee, H.: Inaccessible entropy. In: Proceedings of the 41st Annual ACM Symposium on Theory of Computing,  (2009). https://doi.org/10.1145/1536414.1536497
19. H˚astad, J., Impagliazzo, R., Levin, L.A., Luby, M.: A pseudorandom generator from any one-way function. SIAM J. Comput. 28(4), 1364–1396 (1999). https:// doi.org/10.1137/S0097539793244708
20. Holenstein, T., Sinha, M.: Constructing a pseudorandom generator requires an almost linear number of calls. In: 2012 IEEE 53rd Annual Symposium on Foun- dations of Computer Science,  IEEE (2012). https://doi.org/10.1109/ FOCS.2012.51
27. Rompel, J.: One-way functions are necessary and suﬃcient for secure signatures. In: Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, (1990). https://doi.org/10.1145/100216.100269
29. Vadhan, S., Zheng, C.J.: Characterizing pseudoentropy and simplifying pseudoran- dom generator constructions. In: Proceedings of the 44th Annual ACM Symposium on Theory of Computing,  (2012). https://doi.org/10.1145/2213977. 2214051
30. Yao, A.C.: Theory and application of trapdoor functions. In: 23rd Annual Sympo- sium on Foundations of Computer Science, SFCS 1982,  IEEE (1982). https://doi.org/10.1109/SFCS.1982.45
5. Beaver, D., Micali, S., Rogaway, P.: The round complexity of secure protocols (extended abstract). In: 22nd ACM STOC,  ACM Press, May 1990. https://doi.org/10.1145/100216.100287
10. Brakerski, Z., Gentry, C., Vaikuntanathan, V.: (Leveled) fully homomorphic encryption without bootstrapping. In: Goldwasser, S. (ed.) ITCS 2012,  ACM, January 2012. https://doi.org/10.1145/2090236.2090262
23. Goldreich, O., Micali, S., Wigderson, A.: How to play any mental game or A completeness theorem for protocols with honest majority. In: Aho, A. (ed.) 19th ACM STOC,  ACM Press, May 1987. https://doi.org/10.1145/28395. 28420
24. Goyal, V.: Constant round non-malleable protocols using one way functions. In: Fortnow, L., Vadhan, S.P. (eds.) 43rd ACM STOC,  ACM Press, June 2011. https://doi.org/10.1145/1993636.1993729
32. L´opez-Alt, A., Tromer, E., Vaikuntanathan, V.: On-the-ﬂy multiparty computation on the cloud via multikey fully homomorphic encryption. In: Karloﬀ, H.J., Pitassi, T. (eds.) 44th ACM STOC,  ACM Press, May 2012. https://doi. org/10.1145/2213977.2214086
36. Paskin-Cherniavsky, A.: Secure computation with minimal interaction. Ph.D. the- sis, Computer Science Department, Technion (2012) Round-Optimal and Communication-Eﬃcient Multiparty Computation 95
37. Pass, R.: Bounded-concurrent secure multi-party computation with a dishonest majority. In: Babai, L. (ed.) 36th ACM STOC,  ACM Press, June 2004. https://doi.org/10.1145/1007352.1007393
39. Quach, W., Wee, H., Wichs, D.: Laconic function evaluation and applications. In: Thorup, M. (ed.) 59th FOCS,  IEEE Computer Society Press, October 2018. https://doi.org/10.1109/FOCS.2018.00086
41. Wee, H.: Black-box, round-eﬃcient secure computation via non-malleability ampli- ﬁcation. In: 51st FOCS,  IEEE Computer Society Press, October 2010. https://doi.org/10.1109/FOCS.2010.87
42. Yao, A.C.C.: How to generate and exchange secrets (extended abstract). In: 27th FOCS,  IEEE Computer Society Press, October 1986. https://doi. org/10.1109/SFCS.1986.25
1. Aaronson, S.: Quantum copy-protection and quantum money. In: 2009 24th Annual IEEE Conference on Computational Complexity,  IEEE (2009)
2. Adleman, L.M.: Molecular computation of solutions to combinatorial problems. Science 266(5187), 1021–1024 (1994)
3. Adleman, L.M.: Computing with DNA. Sci. Am. 279(2), 54–61 (1998)
4. Almashaqbeh, G., et al.: Gage mpc: bypassing residual function leakage for non- interactive mpc. PETS 2021(4), 528–548 (2021)
8. Baldwin, M.A.: Protein identiﬁcation by mass spectrometry issues to be considered. Mol. Cell. Proteom. 3(1), 1–9 (2004)
12. Blawat, M., et al.: Forward error correction for DNA data storage. Procedia Com- put. Sci. 80, 1011–1022 (2016)
15. Canetti, R.: Universally composable security. J. ACM 67(5), 28:1–28:94 (2020)
20. Crick, F.H.: On protein synthesis. In: Symposia of the Society for Experimental Biology, vol. 12, p. 8 (1958)
25. Eichhorn, I., Koeberl, P., van der Leest, V.: Logically reconﬁgurable PUFs: memory-based secure key storage. In: Proceedings of the Sixth ACM Workshop on Scalable Trusted Computing,  (2011)
27. Erlich, Y., Zielinski, D.: DNA fountain enables a robust and eﬃcient storage archi- tecture. Science 355(6328), 950–954 (2017)
31. Garg, S., Gentry, C., Halevi, S., Raykova, M., Sahai, A., Waters, B.: Candi- date indistinguishability obfuscation and functional encryption for all circuits. In: FOCS,  IEEE (2013)
32. Glaser, A., Barak, B., Goldston, R.J.: A zero-knowledge protocol for nuclear war- head veriﬁcation. Nature 510(7506), 497–502 (2014)
33. Glish, G.L., Vachet, R.W.: The basics of mass spectrometry in the twenty-ﬁrst century. Nat. Rev. Drug Discov. 2(2), 140–150 (2003)
34. Goldwasser, S., Kalai, Y., Popa, R.A., Vaikuntanathan, V., Zeldovich, N.: Reusable garbled circuits and succinct functional encryption. In: ACM STOC (2013)
38. Grass, R.N., Heckel, R., Puddu, M., Paunescu, D., Stark, W.J.: Robust chemical preservation of digital information on DNA in silica with error-correcting codes. Angew. Chem. Int. Ed. 54(8), 2552–2555 (2015)
45. Lindell, Y.: Anonymous authentication. J. Priv. Conﬁd. 2(2) (2011)
47. MacWilliams, F.J., Sloane, N.J.A.: The theory of error correcting codes, vol. 16. Elsevier (1977)
51. Pappu, R., Recht, B., Taylor, J., Gershenfeld, N.: Physical one-way functions. Science 297(5589), 2026–2030 (2002)
52. Roehsner, M.C., Kettlewell, J.A., Batalh˜ao, T.B., Fitzsimons, J.F., Walther, P.: Quantum advantage for probabilistic one-time programs. Nat. Commun. 9(1), 1–8 (2018)
53. R¨uhrmair, U.: Oblivious transfer based on physical unclonable functions. In: Inter- national Conference on Trust and Trustworthy Computing,  (2010)
54. Wee, H.: On obfuscating point functions. In: ACM STOC,  (2005)
55. Yao, A.C.C.: How to generate and exchange secrets. In: FOCS,  (1986)
8. Alwen, J., Peikert, C.: Generating shorter bases for hard random lattices. In: STACS (2009)
9. Banaszczyk, W.: New bounds in some transference theorems in the geometry of numbers. Mathematische Annalen (1993)
11. Bellare, M., Garay, J.A., Rabin, T.: Distributed pseudo-random bit generators - a new way to speed-up shared coin tossing. In: Burns, J.E., Moses, Y. (eds.) 15th ACM PODC,  ACM, August 1996. https://doi.org/10.1145/248052. 248090
12. Blum, M.: Coin ﬂipping by telephone. In: Proceedings IEEE Spring COMPCOM, (1982)
13. Buchbinder, N., Haitner, I., Levi, N., Tsfadia, E.: Fair coin ﬂipping: tighter analysis and the many-party case. In: Klein, P.N. (ed.) 28th SODA,  ACM- SIAM, January 2017. https://doi.org/10.1137/1.9781611974782.170
17. Cleve, R.: Limits on the security of coin ﬂips when half the processors are faulty (extended abstract). In: 18th ACM STOC,  ACM Press, May 1986. https://doi.org/10.1145/12130.12168
2. Cambridge University Press, Cambridge, UK (2004)
22. Goyal, V., Lee, C.K., Ostrovsky, R., Visconti, I.: Constructing non-malleable com- mitments: a black-box approach. In: 53rd FOCS,  IEEE Computer Soci- ety Press, October 2012. https://doi.org/10.1109/FOCS.2012.47
24. Impagliazzo, R., Levin, L.A., Luby, M.: Pseudo-random generation from one-way functions (extended abstracts). In: 21st ACM STOC,  ACM Press, May 1989. https://doi.org/10.1145/73007.73009
26. Ladner, R.E., Dwork, C. (eds.): 40th ACM STOC. ACM Press, May 2008
29. Nisan, N., Zuckerman, D.: Randomness is linear in space. J. Comput. Syst. Sci. 52(1), 43–52 (1996). https://doi.org/10.1006/jcss.1996.0004
33. Peikert, C., Waters, B.: Lossy trapdoor functions and their applications. In: Ladner, R.E., Dwork, C. (eds.) 40th ACM STOC,  ACM Press, May 2008. https://doi.org/10.1145/1374376.1374406 154 D. Abram et al.
35. Yeung, R.: A new outlook on Shannon’s information measures. IEEE Trans. Inf. Theory 37(3), 466–474 (1991). https://doi.org/10.1109/18.79902
3. We then propose a ﬁrst hardware- oriented instance in Sect. 4 for which we analyze the mathematical security in Sect. 5 and the implementation eﬃciency & security in Sects. 6 and 7. 3 High-level Rationale and Security Arguments We now provide a high-level rationale and security arguments for FPMτ TBCs. 3.1 TWEAKEY Framework and LED-Like Design FPMτ ciphers follow the TWEAKEY framework proposed by Jean et al.
1. This approach is not new in the literature, as it has been already exploited in the block cipher LED [51]. Its main advantage is to allow a very simple security analysis concerning related-tweak attacks. More precisely, since the tweaks are public, the attacker can always control them. Similar to a related-key attack [15], in a related-tweak attack the attacker encrypts (resp., decrypts) the same or diﬀerent plaintext(s) (resp., ciphertexts) under several related tweaks. (Anticipating the detailed analysis of Sect. 5, we emphasize that related-tweak attacks are usually based on statistical properties and not on algebraic ones.) A possible way to avoid such attacks is to treat the tweaks exactly as the plaintexts. That is, not to make any distinction between plaintexts and tweaks. This is what is done in a sponge/duplex construction [12, 13], but it requires a larger state in order to arrange the inner part, which is not suitable in our case. Another approach to prevent related-tweak attacks is the one proposed in
[51] to prevent related-key attacks. That is, adding the tweak every Nr ą 1 rounds. The argument for τ “ 1 is relatively simple: – A statistical attack as the diﬀerential one [18,19] exploits the probability distribution of a non-zero input diﬀerence leading to an output diﬀerence after a given number of rounds. The security is achieved if the probability of any diﬀerential characteristic is much smaller than the security level; – Given T P Fn p, assume for simplicity that all the Ti’s P Fn p are equal to T; – If a diﬀerence is inserted in the tweak, then every sub-tweak Ti will be active; – Hence, it is impossible to force two consecutive steps S to be non-active (i.e., with zero input and zero output diﬀerences). That is, for every two consecutive steps S of Nr-rounds, at least one of them must be active. Indeed, let’s assume that the output diﬀerence of the i-th step S coincide with the diﬀerence in Ti. In this case, the next i ` 1-th step S is not active, since its input diﬀerence is equal to zero. But the next tweak Ti`1 will introduce again the diﬀerence, making the next i`2-th step S active. Using the number of active steps Ns (each one composed of Nr rounds), it is therefore possible to provide simple security arguments for preventing diﬀerential and other statistical attacks, which reduce to the security of the public permutation S (which is independent 196 L. Grassi et al. of the tweaks and the master key). We refer to the full version of this paper [47] for an initial analysis (based on published results) regarding the selection of the number of steps Ns independently of their internal structure. The previous argument can be generalized for a non-trivial tweak scheduling T : Fτ¨n p ” (Fn p)τ Ñ (Fn p)˚, for example if the following properties are satisﬁed: 1) T is bijective, and 2) Tj,¨ P Fn p is active if and only if T (j) P Fn p is active. Equivalently, this second condition is satisﬁed if there exist τ invertible maps T0, T1, . . . , Tτ´1 over Fn p such that Tj,i “ Ti`1 j (T (j)) for each i ě 0, where Ti`1 j :“ Tj ˝ Tj ˝ . . . ˝ Tj for i times. (We emphasize that this is not a necessary condition.) In our case, we achieve this property by deﬁning Tj,¨ via a shuﬄe of the Fp-words of T (j). (The mapping of each Fp does not aﬀect this property.) A detailed argument will be given for small-pSquare with τ “ 1, 2 in Sect. 5.1. We leave the question whether adding the tweakey every round could lead to improved (but harder to analyze) security as a scope for further research. 3.2 Rationale Behind the Generalized Type-II Feistel Scheme The main motivation behind the choice of deﬁning FPMτ ciphers based on a gen- eralized Feistel structure relates to the goal of having TBCs with cheap inverses that are useful in some leakage-resistant modes of operation [7,10]. This result can be achieved via 1) a Feistel or Lai-Massey scheme [45,62,84], 2) an SPN scheme with the “reﬂection” property like Prince [14,22,23], or 3) an SPN scheme in which every round – without the constant additions – is an involution (that is, R “ R´1) like Noekon [32], Khazad
[82] or Iceberg [82]. Even if all options are valid from a security viewpoint, the ﬁrst one comes with the least constraints on its internal components, which is desirable in our setting in order to enable these components to be selected primarily for their properties against leakage. After discarding Type-I Feistel schemes that require too many rounds for achieving full diﬀusion, we opted for Type-II generalized Feistel networks instead of Type-III ones. As witnessed by designs like Hight
[53] or Cleﬁa [79], they generally oﬀer a good security vs. eﬃciency compromise. 3.3 Rationale and Construction of the Function F As mentioned in Sect. 2.3, the F functions aim to ensure good non-linear diﬀusion while remaining bijective (in order to simplify the security analysis). For func- tions Gi,j over Fp that are themselves bijective, this could be directly obtained with two SPN rounds. Yet, and as mentioned in the introduction, one natural candidate Gi,j function is the square power map, which leads to eﬃcient masked implementations [27]. As a result, we opted for F functions based on two rounds of a generalized Feistel network.5 We selected the Type-III version which is more similar to SPNs in terms of their number of non-linear Gi,j functions and replaced the middle shift of the Fp-words by an invertible linear layer in order to speed up the non-linear diﬀusion, an idea that resembles the one in [8]. 5 For instances relying on invertible Gi,j functions, we suggest using two SPN rounds. Generalized Feistel Ciphers for Eﬃcient Prime Field Masking 197 Fig.
3. F-function used in small-pSquare. Regarding the choice of the linear layer, we opted for an MDS matrix which allows to achieve full non-linear diﬀusion over Fc p in only two rounds. Examples include lightweight candidates [39,60,66] adapted to the prime case (where the multiplication per two can be cheap – see Footnote 2). Such MDS matrices could be replaced by any invertible matrix with a smaller branch number that allows to get full non-linear diﬀusion in two rounds, as the ones in [65]. Finally, the round constant additions aim to (i) diﬀerentiate the rounds (e.g., for preventing slide attacks [20,21]), (ii) break any ﬁxed points, and (iii) break any invariant subspace [48,63,64]. Since x ÞÑ x2 has only two ﬁxed points (namely, 0 and 1) and since Fp does not have any non-trivial subspace (as opposed to F2t ” Ft 2), we believe that one Fp-constant addition before each non-linear Type-III generalized Feistel layer is suﬃcient. As an extra condition when using Mersenne primes, we require that the round constants do not belong to any subspace of Fρ 2 (where p “ 2ρ ´ 1). The choice to generate them via a bit rotation of a ﬁxed mathematical constant like π is for eﬃcient (hardware) implementation purposes. The mathematical constant must be chosen such that all the rotations are in {0, 1, . . . , p ´ 1} where p is the prime that deﬁnes Fp. 4 small-pSquare: a Hardware-oriented Instance In this section, we provide the speciﬁcations of a ﬁrst instance of an FPMτ cipher. As mentioned in the introduction, its high-level rationale follows two main guidelines. First, we aim to exploit the recently proposed secure squaring gadgets from [27], which were shown to be more eﬃcient than secure multiplications in Fp. As a result, we use the square as power map for the Gi,j functions of Sect. 2.3. Second, we aim to enable eﬃcient hardware implementations. As a result, we use a small Mersenne prime p “ 27 ´
1. We then propose to use the rounds depicted in the right part of Fig. 2, leading to a FPMτ(7, 4, 4) cipher that provides « 7 ˆ 4 ˆ 4 “ 112 bits of security and we denote as small-pSquare. We ﬁrst detail the diﬀerent components of the function F (depicted in Fig. 3), then ﬁnalize the speciﬁcation of the tweak scheduling algorithm and conclude with the suggested number of rounds per steps and steps. 198 L. Grassi et al. Non-Linear Layer. The non-linear layer of small-pSquare is instantiated with the following F4 27´1 Ñ F4 27´1 mapping: (x0, x1, x2, x3) ÞÑ  x0 ` x2 1, x1 ` x2 2, x2 ` (x3 ` ci,j)2, x3 ` ci,j  , where ci,j is a round constant speciﬁed thereafter. Linear Layer. The linear layer of small-pSquare is instantiated with the invert- ible matrix M P F4ˆ4 27´1 deﬁned as: M “ ⎡ ⎢⎢⎣ 3 2 1 1 7 6 5 1 1 1 3 2 5 1 7 6 ⎤ ⎥⎥⎦. This matrix has been introduced by Duval et al.
[39] and is MDS over F27´1. It can be implemented as a Type-II Feistel-like construction as shown in Fig. 3, with only 8 additions and a depth of 4 (which is optimal for 8 additions). We recall that the doubling operation (i.e., x ÞÑ 2 ¨ x) modulo a Mersenne prime is just a bit rotation, hence free in hardware and cheap in software. Round Constants. The ﬁrst 64 bits of the binary sequence of π are (in hex- adecimal): πbin64 “ 0xC90FDAA22168C234. Let us denote the bit-wise rotation left via Î. Then, the left F-function at round i uses the round constants: – ci,0 “ (πbin64 Î i) mod 27, – ci,1 “ (πbin64 Î (i ` 16)) mod 27, while the right F-function at round i uses the round constants: – ci,2 “ (πbin64 Î (i ` 32)) mod 27, – ci,3 “ (πbin64 Î (i ` 48)) mod 27. As no sequence of 7 consecutive 1 s exists in πbin64, all ci,0, ci,1, ci,2, ci,3’s P F27´1. Tweak Scheduling (τ ě 1 Only). Let Π16 be the shuﬄe of the 16 F27´1–words in the tweak schedule sub-tweak word permutation deﬁned as: Π16(x0∥x1∥. . . ∥x15) “ x9∥x5∥x13∥x15∥x12∥x7∥x14∥x2∥x4∥x6∥x8∥x3∥x10∥x1∥x11∥x0. Π16 has a cycle period of 140 which is the largest we found for 16-element shuﬄes (and more than suﬃcient for our envisioned step numbers). On each F27´1-word, we then apply a bit-shuﬄe Ψl deﬁned as @l P {0, 1, . . . , 15} : Ψl(x) “ ψ7(2l ¨ x mod 27) , where the multiplication with 2l corresponds to a shift of the bits of l positions (when working over F7 2), and where ψ7 is deﬁned as: ψ7 x “ 6  i“0 xi ¨ 2i  “ x0 ¨25 `x1 ¨23 `x2 ¨20 `x3 ¨24 `x4 ¨21 `x5 ¨26 `x6 ¨22, Generalized Feistel Ciphers for Eﬃcient Prime Field Masking 199 for each x P F27´1 where x0, x1, . . . , x6 P {0, 1}. The cycle period of ψ7 is 12 (i.e., the maximum possible for a permutation over 7 bits). Moreover, the polynomial corresponding to ψ7 over F27´1 is of degree 125 (i.e., the maximum possible) and contains 46 out of the 127 monomials possible. We refer to the full version of this paper
[47] for details on ψ7, where we also prove that the polynomial over F2ρ´1 corresponding to any bit shuﬄing only contains monomials of odd degree. Number of Rounds. For a security level of 112 bits and the aforementioned parameters (p “ 27 ´ 1; b “ 4, c “ 4), we use Nr “ 4 rounds per step and we use Ns “ 9 steps for τ “ 0, Ns “ 16 steps for τ “ 1 and Ns “ 21 steps for τ “ 2. The security analysis that supports these choices is given in the next section. 5 Mathematical Security Analysis of small-pSquare We now evaluate the security of small-pSquare against standard attack vectors, including classical and truncated diﬀerential attacks and algebraic attacks (based on interpolation, linearization, higher-order diﬀerentials and Gr¨obner bases). We describe the attacks having a larger impact on small-pSquare’s number of rounds in the paper. Details of further attacks are presented in the full version [47]. Overview of the Attacks. As we are going to show, the main attack vector against small-pSquare is diﬀerential cryptanalysis [18,19], which we present in detail in Sect. 5.1 for the case τ “ 0 and the case τ ě 1 (for which we consider related-tweak diﬀerential attacks). In this last case, we exploit the strategy intro- duced by the LED designers and recalled in Sect. 3.1 for guaranteeing security against related tweaks. Truncated
[59] and impossible diﬀerential
[17] crypt- analysis as well as other statistical attacks including linear cryptanalysis [68] and boomerang attacks
[87] are detailed in the full version [47]. Contrary to MPC-/FHE-/ZK-friendly schemes deﬁned over prime ﬁelds, and similar to clas- sical/traditional symmetric primitives, algebraic attacks are not the main threat against small-pSquare in our analysis, essentially due to the small size of the prime p “ 27 ´ 1 and the high number of variables n “
16. For this reason, we discuss the degree and density of the polynomial representation of small-pSquare in Sect. 5.2, limit ourselves to linearization attacks
2. Indeed, let (x0, x1, x2, x3) ÞÑ (x0, x2 0 ` x1, x2 1 ` x2, x2 2 ` x3) be the Feistel layer, and keep in mind that the branch of the MDS matrix M is
5. Then: – If no square map is active in the ﬁrst Feistel layer of F (hence, x3 is the only active component), then only one output is active at its output. After the multiplication with the MDS matrix, all inputs of the second Feistel layer are active, which implies the result. A similar result holds if only one square map is active in the ﬁrst Feistel layer, which corresponds to the case in which only one among {x0, x1, x2} is active. In such a case, two outputs of the ﬁrst Feistel layer are active, which implies that at least 3 inputs of the second Feistel layer are active and at least 3 square maps are active for each F; – If two inputs are active, the best scenario for the attacker occurs when the active inputs are either {x0, x3} or {x1, x3}. In this case, exactly one square map is active in the ﬁrst Feistel layer (due to the fact that x3 does not activate any square map), and three outputs of the Feistel layer are active (due to the fact that x0, x1 and x3 are not consecutive). Since the matrix is MDS, then at least two inputs are active for the second Feistel layer, which implies that at least one square map is active in the second Feistel layer. As a result, at least 2 square maps are active for each F; 6 Binary schemes like AES or SHA-3/Keccak have been shown vulnerable to statistical attacks mainly, while algebraic attacks gain more popularity recently due to the raising of symmetric schemes designed for applications as MPC, FHE, and ZK. Still, symmetric schemes designed for such applications are not tweakable designs. Generalized Feistel Ciphers for Eﬃcient Prime Field Masking 201 – If 3 or 4 inputs are active, at least two square maps are active for each F. Overall, it directly follows that DPmax(x ÞÑ F(x)) “ p´2 « 2´14. Diﬀerential property of S. As shown in [28,83], at least four consecutive rounds of Type-II generalized Feistel network are necessary to reach full diﬀusion (i.e., Nr ě 4). Over 4 consecutive rounds, at least 3 functions F are active (as visually illustrated in the full version [47]). As a result, by setting Nr “ 4, it directly follows that DPmax(x ÞÑ S(x)) ď DPmax(x ÞÑ S(x))3 ď p´6 « 2´42. Number of Steps for Security. Finally, we compute the minimum number of steps Ns for guaranteeing security. Due to clustering eﬀect (that is, due to the fact that several diﬀerential characteristics can be used together for setting up the attack) and due to the possibility to exploit a Meet-in-the-Middle approach for setting up the attack, we claim that the scheme is secure if every diﬀerential characteristic has probability smaller than 2´2.5¨κ « 2´280 for an arbitrary factor 2.5,7 where κ “ 112 “ 7 ¨ 16 is our target security level. Moreover, we conjecture that the attacker cannot skip more than 2 steps S by a simple partial key- guessing, since one step S is suﬃcient for achieving full diﬀusion. Case: τ “
0. By simple computation, we have Ns ě ⌈280{42⌉` 2 “ 7 ` 2 “ 9 where 2 steps S are added for preventing partial key-guessing strategies. Case: τ “
1. Following the argument proposed by LED’s designers in [51, Sect. 3] and recalled in Sect. 3.1, the attacker can choose related tweaks such that only one out of two consecutive steps S is active. As a result, it is suﬃcient to double the number of steps S obtained for τ “ 0 to guarantee security. That is, Ns ě 2 ¨ 7 ` 2 “ 16, where we again add 2 steps S for preventing partial key-guessing. Case: τ “
2. In this case, the attacker has more freedom in the choice of the related tweaks. Still, we can adapt the previous security argument as follows. Let us consider separately the next two cases: (i) both T (0) and T (1) are active (hence, T0,i and T1,i are both active for each i ě 0 due to the deﬁnition of the tweak schedule), and (ii) only one among T (0) and T (1) is active (hence, only one among T0,i and T1,i is active for each i ě 0 due to the deﬁnition of the tweak schedule). In the ﬁrst case, the analysis proposed for τ “ 1 applies, which implies that at least one among two consecutive steps S is active. In the second case, w.l.o.g., we assume that T (0) is active and T (1) is inactive. We introduce a “super-step” S2 :“ S˝S as the application of two consecutive steps S. By working as before, we can deduce at least one among two consecutive super-steps S2 is active. Moreover, if a super-step is active, then the two steps S that compose it are active. Indeed, the fact that S2 is active implies that T0,i introduces the diﬀerence in the ﬁrst S. Its output diﬀerence cannot be canceled by T1,i, which is inactive due to the tweak schedule and due to the assumption. Hence, both steps of S2 are active. The same result applies if T (1) is active and T (0) is active. This reasoning implies that Ns ě 14 is a necessary condition for security. Yet, we have to keep in mind that the attacker can potentially skip one super-step S2 7 We take inspiration on the AES-128, which has 10 “ 2.5 ¨ 4 rounds, where 4 is the minimum number of rounds for preventing classical diﬀerential attacks. 202 L. Grassi et al. at each side of the cipher by working with input (respectively, output) diﬀerences in the plaintexts (resp., ciphertexts) that cancel out with the ones in the tweaks, leading S2 to be inactive. As a result, we require that Ns ě 2 ¨ 7 ` 4 ` 2 “ 20, where we again add 2 steps S for preventing partial key-guessing. 5.2 Degree and Density of the Polynomial Representation In general, algebraic attacks try to take advantage of the “simple” algebraic description of a scheme for breaking it, where the simplicity can relate (among other properties) to the low degree of the encryption/decryption function, the sparsity of the polynomial representation of such functions, or a particular struc- ture of the algebraic system generated by the cipher. The main ingredient for pre- venting these attacks is the minimal number of rounds such that the polynomial representations of the cipher have a suﬃcient degree and too many monomials for the attacks to apply with a complexity lower than 2κ. In this section, we there- fore study these two characteristics, pointing out that the encryption function of small-pSquare with a ﬁxed key and tweak could be analyzed as a mapping over Fp16 for p “ 27´1. Nevertheless, since all the operations of F are at the basis ﬁeld level (squaring in Fp), the ﬁeld we consider for the cryptanalyses is Fp, and the polynomials built by an adversary belong to Fp[x0, . . . , x15]{(xp 0 ´1, . . . , xp 15 ´1). Note that similar results hold in the context of related tweaks, for which the adversary can consider the same polynomials but with more variables. Growth of the Degree. We ﬁrst focus on the minimal degree that a polynomial in this representation can have, and the number of diﬀerent monomials that appear in an algebraic system obtainable, after r rounds. Note that the degree in one variable is at most p ´ 1, the total degree is then at most 16(p ´ 1), and the total number of monomials is p16. The degree of F is deg(F) “
4. More precisely, it is 4 in three components and 2 in the last one. The degree of its inverse is deg(F´1) “ 82 “
3. Then, we get an upper bound on rm based on our experiments (the real value could be smaller, taking the upper bound is conservative). With p “ 3 we obtain monomials depending on 10 variables in the polynomials in position 1, 2 and 3 and in positions 9, 10 and 11 by symmetry of the Type-II Feistel structure. These monomials contain all the variables from x0 to x7 and x8 to x15 respectively. Calling X and Y monomials of this shape, we get that at round 5 there are terms of shape X+Y in the polynomials in positions 0, 1, 2, 3, 8, 9, 10 and 11, therefore giving complete monomials after passing through F due to the square operations. Since only half of the input goes through F at each round, one more round is needed to obtain these complete monomials in each position, therefore rm ď
7. When moving to p “ 27 ´ 1 we can only observe more monomials (since all the ones with a coeﬃcient multiple of 127 rather than 3 are canceled). Combined with the fact that the degree is at least 22r´3 as shown before, we conclude that 5 extra rounds are suﬃcient to wrap around p and reach any degree in one variable. This gives us a bound of 12 rounds (equivalently, three steps S) to expect dense polynomials in the 16 positions. 5.3 Linearization Attack Given a system of polynomial equations, one possible way to solve it is via the linearization technique which works by turning it into a system of linear equa- tions and adding new variables that replace all the monomials in the system of degree larger than
2. Cost and performance comparison of masked SKINNY-128-256 and small- pSquare (τ “ 1) hardware implementations evaluated in TSMC 65 nm technology at typical operating conditions for 100 MHz and 250 MHz clock. Cipher Ref. Par. Frequ d Pip. Crit. Path Area Power Latency Random [MHz] [ns] [GE]
[mW] [cyc/enc] [bit/cyc] SKINNY-128-256 [58] 128 100|250 2 1.519177 19026.75 2.8547 432/1 128 3 1.763878 38828.75 6.2545 432/1 384 4 1.839592 65502.00 8.9225 432/1 768 2 ✓ 1.566238 58475.50 13.6144 432/9 128 3 ✓ 1.801272 94611.50 21.6698 432/9 384 4 ✓ 1.882408 137625.50 30.8983 432/9 768 32 100|250 2 1.743940 9274.50 1.0755 2160/1 32 3 1.903482 15999.00 2.0608 2160/1 96 4 1.823993 24442.00 8.2697 2160/1 192 2 ✓ 1.885406 39016.25 9.1220 2160/9 32 3 ✓ 1.943746 57757.00 13.4186 2160/9 96 4 ✓ 1.909085 78243.00 17.9452 2160/9 192 [85] 128 100|250 2 3.715469 18035.75 2.5276 288/1 32 3 3.232731 28740.75 4.1347 288/1 96 4 3.849724 41136.75 5.9918 288/1 192 small-pSquare [this] 112 100 2 9.845555 21714.50 2.9370 128/1 84 3 9.854049 41982.50 5.6533 128/1 210 4 9.852280 62587.75 8.4822 128/1 504 2 ✓ 9.852014 30730.25 4.4491 128/2 168 3 ✓ 9.854022 65273.00 9.2764 128/2 420 4 ✓ 9.853921 101168.00 14.3426 128/2 1008 250 2 3.857306 29438.50 3.7809 128/1 84 3 3.861372 52073.50 6.9574 128/1 210 4 3.907730 78441.00 10.5274 128/1 504 2 ✓ 3.852503 40414.75 5.5467 128/2 168 3 ✓ 3.857475 77556.50 11.0357 128/2 420 4 ✓ 3.859051 121589.25 17.4111 128/2 1008 56 100 2 9.847473 15332.25 1.9296 256/1 42 3 9.851035 27215.75 3.4077 256/1 105 4 9.852068 39237.50 4.9897 256/1 252 2 ✓ 9.848985 20735.75 2.8794 256/2 84 3 ✓ 9.941982 39958.75 5.5274 256/2 210 4 ✓ 9.851659 59404.75 8.2398 256/2 504 250 2 3.855009 20471.00 2.4330 256/1 42 3 3.858206 34485.25 4.2527 256/1 105 4 3.859086 48511.25 6.1763 256/1 252 2 ✓ 3.858980 26823.25 3.5092 256/2 84 3 ✓ 3.858999 48147.50 6.5390 256/2 210 4 ✓ 3.857775 72245.00 9.9639 256/2 504 Cipher = Evaluation target, either SKINNY-128-256 or small-pSquare (τ “ 1). Ref. = Reference, i.e., related publication, AGEMA is cited for automatically generated circuits. Par. = Parallelism, i.e., size of the state that is operated on in parallel measured in bits. Freq. = Synthesis frequency measured in Megahertz (MHz). d = Number of shares, resulting in security order d ´ 1. Pip. = Design is pipelined (✓) or not ( ). Crit. Path = Critical path of the synthesized circuit measured in nanoseconds (ns). Area = Area consumption of the synthesized circuit measured in gate equivalents (GE). Power = Power consumption of the synthesized circuit measured in milliwatts (mW). Latency = Latency of the synthesized circuit measured in clock cycles per encryption(s). Random = Fresh randomness consumption measured in bits per clock cycle. 208 L. Grassi et al. numbers and tweak schedule. Since this concrete implementation uses a speciﬁc implementation of the SKINNY 8-bit S-box that is tailored towards a certain set of optimization goals, we also wanted to include other, more general, masked SKINNY-128 implementations in our comparison. To this end we have employed the Automated Generation of Masked Hardware (AGEMA) tool published at TCHES 2022
[9] or
3. Comparative side-channel evaluation of pipelined masked SKINNY-128-256 and small-pSquare hardware implementations. Cipher Par. CPR d mean SNR median SNR TVLA det. compl. SASCA compl. SKINNY-128-256 128 9 2 0.0023 0.0021 71 000 25 000 3 0.0015 0.0019 811 000 362 000 4 0.0013 0.0010 57 000 000 29 832 000 32 45 2 0.0064 0.0048 52 000 6 000 3 0.0026 0.0028 680 000 157 000 4 0.0020 0.0016 48 000 000 17 169 000 small-pSquare 112 2 2 0.0021 0.0019 321 000 213 000 3 0.0032 0.0013 8 040 000 4 002 000 4 0.0016 0.0011 ą 100 000 000 ą 100 000 000 56 4 2 0.0073 0.0031 238 000 45 000 3 0.0030 0.0025 7 040 000 1 754 000 4 0.0018 0.0020 ą 100 000 000 ą 100 000 000 Cipher = Evaluation target, either SKINNY-128-256 or small-pSquare (τ “ 1). Par. = Parallelism, i.e., size of the state that is operated on in parallel measured in bits. CPR = Cycles per round, i.e., latency of one round function computation measured in cycles. d = Number of shares, resulting in security order d ´ 1. mean SNR = Mean maximum SNR of all S-box/Squaring input shares in the first round. median SNR = Median maximum SNR of all S-box/Squaring input shares in the first round. TVLA det. compl. = Minimum number of traces to surpass the TVLA detection threshold. SASCA compl. = Minimum number of traces to achieve key rank 1 in a SASCA key recovery. Table 3 summarizes the evaluation results collected for the 12 diﬀerent masked implementations, 6 ˆ SKINNY-128-256 and 6 ˆ small-pSquare. It is apparent from the mean and median side-channel SNRs computed over all ﬁrst-round 8-bit S-box (SKINNY-128-256) input shares or 7-bit Squaring (small- pSquare) input shares, that the quality of observations an adversary can make of individual words processed in the circuits is quite similar in both cases (binary- ﬁeld or prime-ﬁeld cipher). Thus, the noise levels are not expected to signiﬁ- cantly impact the following investigation. We have plotted one set of evaluation results in Fig. 4 for the concrete example of serialized pipelined implementations with 3 shares. For all 2-, 3- and 4-share implementations respectively, we have ﬁrst measured 1 million, 10 million and 100 million traces, in a randomly inter- leaved sequence of measurements for ﬁxed and for random inputs, according to the Test Vector Leakage Assessment (TVLA) methodology [77]. The resulting non-speciﬁc t-test results are illustrated in the third row of Fig.
4. The imple- mentations satisfy the expected statistical security order in the experiments, as the smallest moment where leakage is detected is equal to the number of shares. The same holds for all evaluated circuits in Table
3. As a next step we performed exemplary key recovery attacks on the most leaking (highest SNR) 212 L. Grassi et al. 0 100 200 300 400 500 Time Samples Power Cons. 0 100 200 300 400 500 Time Samples Power Cons. 0 100 200 300 400 500 Time Samples 0 0.01 SNR 0 100 200 300 400 500 Time Samples 0 0.01 SNR 0 0.5 1 No. of Traces 107 0 5 10 15 t-statistics 3rd order 1st to 2nd order 0 0.5 1 No. of Traces 107 0 5 10 15 t-statistics 3rd order 1st to 2nd order 100 101 102 103 104 105 106 107 No. of Traces 20 28 Key Rank 100 101 102 103 104 105 106 107 No. of Traces 20 27 Key Rank Fig.
4. Exemplary SCA results of serialized second-order masked SKINNY-128-256 (left) and small-pSquare (right) hardware implementations. From top to bottom: Sam- ple traces, SNRs (1M traces), Fixed-vs-random t-tests (10 M traces), Proﬁled SASCA (1 M proﬁling, 10 M attack traces). 8-bit or 7-bit word respectively of the state. In order to extract the most infor- mation from the traces and reduce the eﬀective noise level we have employed a proﬁled horizontal Soft-Analytical Side-Channel Attack (SASCA) [86]. In a ﬁrst step all relevant intermediate values are proﬁled over multiple clock cycles to obtain multivariate templates. Next, a Linear Discriminant Analysis (LDA) is used to perform a linear dimensionality reduction which maximizes class sepa- ration on the proﬁling traces (always 1M) [81]. Finally, on the distinct attack trace set, likelihoods for all intermediate values and corresponding templates are collected separately, before a discrete probability distribution of the secret value is derived using belief propagation inside a SASCA tree graph that contains mul- tiple intermediate computation stages of the masked S-box or squaring. These procedures are readily implemented in the publicly available SCALib library [25]. We then estimate the average rank of the correct key (over 1 000 iterations) with the probabilities obtained from all the attack traces. The results of that proce- dure plotted over the number of attack traces are shown in the bottom row of Fig.
19. Biham, E., Shamir, A.: Diﬀerential Cryptanalysis of the Data Encryption Standard. Springer (1993). https://doi.org/10.1007/978-1-4613-9314-6
25. Cassiers, G., Bronchain, O.: Scalib: a side-channel analysis library. J. Open Source Softw. 8(86), 5196 (2023)
26. Cassiers, G., Gr´egoire, B., Levi, I., Standaert, F.-X.: Hardware private circuits: from trivial composition to full veriﬁcation. IEEE Trans. Comput. 70(10) (2021)
32. Daemen, J., Peeters, M., Van Assche, G., Rijmen, V.: Nessie Proposal: NOEKEON. In: First Open NESSIE Workshop (2000)
69. Moos, T., Moradi, A., Richter, B.: Static power side-channel analysis of a threshold implementation prototype chip. In: Design, Automation & Test in Europe Confer- ence & Exhibition (DATE), 2017 (2017)
72. Del Pozo, S.M., Standaert, F.-X., Kamel, D., Moradi, A.: Side-channel attacks from static power: when should we care?. In: DATE (2015)
82. Standaert, F.-X., Piret, G., Rouvroy, G., Quisquater, J.-J.: FPGA implementations of the ICEBERG block cipher. Integration 40(1), 20–27 (2007)
1. Adams, D.Q., et al.: Lower bounds for leakage-resilient secret sharing schemes against probing attacks. In: ISIT 2021 (2021)
4. Bafna, M., Sudan, M., Velusamy, S., Xiang,D.: Elementary analysis of isolated zeroes of a polynomial system (2021). arXiv preprint arXiv:2102.00602
11. Chattopadhyay, E., et al.: Extractors and secret sharing against bounded collusion protocols. In: 61st FOCS,  IEEE Computer Society Press, November 2020. https://doi.org/10.1109/FOCS46700.2020.00117
12. Con, R., Tamo, I.: Nonlinear repair of reed-Solomon codes. IEEE Trans. Inf. Theory 68(8), 5165–5177 (2022). https://doi.org/10.1109/TIT.2022.3167615
13. Costes, N., Stam, M.: Redundant code-based masking revisited. IACR TCHES. 2021(1), 426–450 (2021). https://tches.iacr.org/index.php/TCHES/article/view/ 8740, https://doi.org/10.46586/tches.v2021.i1.426-450
14. Dimakis, A.G., Godfrey, P.B., Wu, Y., Wainwright, M.J., Ramchandran, K.: Net- work coding for distributed storage systems. IEEE Trans. Inf. Theory 56(9), 4539– 4551 (2010)
15. El Rouayheb, S., Ramchandran,K.: Fractional repetition codes for repair in dis- tributed storage systems. In: 2010 48th Annual Allerton Conference on Communi- cation, Control, and Computing (Allerton),  IEEE (2010) 314 H. K. Maji et al.
18. Goparaju, S., El Rouayheb, S., Calderbank, R., Vincent Poor, H.: Data secrecy in distributed storage systems under exact repair. In: 2013 International Symposium on Network Coding (NetCod),  IEEE (2013)
19. Goparaju, S., Fazeli, A., Vardy, A.: Minimum storage regenerating codes for all parameters. IEEE Trans. Inf. Theory 63(10), 6318–6328 (2017)
20. Goyal, V., Kumar, A.: Non-malleable secret sharing. In: Diakonikolas, I., Kempe, D., Henzinger, M. eds. 50th ACM STOC,  ACM Press, June 2018. https://doi.org/10.1145/3188745.3188872
21. Guruswami, V., Wootters, M.: Repairing reed-Solomon codes. In: Wichs, D., Man- sour, Y., (eds.) 48th ACM STOC,  ACM Press, June 2016. https:// doi.org/10.1145/2897518.2897525
22. Guruswami, V., Wootters, M.: Repairing reed-Solomon codes. IEEE Trans. Inf. Theory 63(9), 5684–5698 (2017). https://doi.org/10.1109/TIT.2017.2702660
26. Kumar, A., Meka, R., Sahai, A.: Leakage-resilient secret sharing against colluding parties. In: Zuckerman, D., (ed.) 60th FOCS,  IEEE Computer Society Press, November 2019. https://doi.org/10.1109/FOCS.2019.00045
29. Maji, H.K., Nguyen, H.H., Paskin-Cherniavsky, A., Wang, M.: Improved bound on the local leakage-resilience of Shamir’s secret sharing. In: IEEE International Sym- posium on Information Theory, ISIT 2022, Espoo, Finland, June 26–July 1, 2022, IEEE (2022). https://doi.org/10.1109/ISIT50566.2022.9834695
35. Papailiopoulos, D.S., Dimakis, A.G., Cadambe, V.R.: Repair optimal erasure codes through Hadamard designs. IEEE Trans. Inf. Theory 59(5), 3021–3037 (2013)
36. Vinayak Rashmi, K., Shah, N.B., Vijay Kumar, P.: Optimal exact-regenerating codes for distributed storage at the MSR and MBR points via a product-matrix construction. IEEE Trans. Inf. Theory 57(8), 5227–5239 (2011)
37. Shamir, A.: How to share a secret. Commun. Assoc. Comput. Mach. 22(11), 612– 613 (1979)
39. Tamo, I., Wang, Z., Bruck, J.: Zigzag codes: MDS array codes with optimal rebuild- ing. IEEE Trans. Inf. Theory 59(3), 1597–1616 (2012)
40. Wang, Z., Tamo, I., Bruck, J.: Explicit minimum storage regenerating codes. IEEE Trans. Inf. Theory 62(8), 4466–4480 (2016)
41. Wooley, T.D.: A note on simultaneous congruences. J. Number Theory. 58(2), 288–297 (1996)
42. Ye, M., Barg, A.: Explicit constructions of high-rate MDS array codes with optimal repair bandwidth. IEEE Trans. Inf. Theory 63(4), 2001–2014 (2017)
43. Ye, M., Barg, A.: Explicit constructions of optimal-access MDS codes with nearly optimal sub-packetization. IEEE Trans. Inf. Theory 63(10), 6307–6317 (2017)
44. Zhao, X.: A note on multiple exponential sums in function ﬁelds. Finite Fields Appl. 18(1), 35–55 (2012)
[BMG07] Barak, B., Mahmoody-Ghidary, M.: Lower bounds on signatures from sym- metric primitives. In: 48th Annual IEEE Symposium on Foundations of Computer Science (FOCS 2007),  IEEE (2007)
[BRSV17] Ball, M., Rosen, A., Sabin, M., Vasudevan, P.N.: Average-case ﬁne-grained hardness. In: 49th ACM STOC,  ACM Press, June 2017
[Mer78] Merkle, R.C.: Secure communications over insecure channels. Commun. ACM 21(4), 294–299 (1978)
[Pol75] Pollard, J.M.: A monte Carlo method for factorization. BIT 15, 331–334 (1975). http://cr.yp.to/bib/entries.html#1975/pollard
[Sha71] Shanks, D.: Class number, a theory of factorization, and genera. In: Pro- ceedings of Symposium Mathematical Society,  (1971)
[Bai+21] Bai, S., et al.: CRYSTALSDilithium: algorithm speciﬁcations and sup- porting documentation (Version 3.1). Current: https://pq-crystals.org/ dilithium/resources.shtml; Stable: https://doi.org/10.13154/tches.v2018.i1. 238-268 (2021)
[Gro96] Grover, L.K.: A fast quantum mechanical algorithm for database search. In: Proceedings of the 28th ACM Symposium on the Theory of Computing (STOC),  (1996). https://doi.org/10.1145/237814.237866 Evaluating the Security of CRYSTALS-Dilithium in the QROM 445
[Pei07] Peikert, C.: Limits on the hardness of lattice problems in LP norms. In: Twenty-Second Annual IEEE Conference on Computational Complexity (CCC’07),  (2007). https://doi.org/10.1109/CCC.2007.12
[Reg09] Regev, O.: On lattices, learning with errors, random linear codes, and cryp- tography. J. ACM 56(6) (2009). ISSN: 0004-5411. https://doi.org/10.1145/ 1568318.1568324
[SE94] Schnorr, C.P., Euchner, M.: Lattice basis reduction: improved practical algo- rithms and solving subset sum problems. Math. Program. 66(1), 181–199 (1994). https://doi.org/10.1007/BF01581144
[Zha15] Zhandry, M.: A note on the quantum collision and set equality problems. Quantum Inf. Comput. 15(7-8), 557–567 (2015). ISSN: 1533–7146. https:// doi.org/10.26421/QIC15.7-8-2
2. van Baarsen, A., Pu, S.: Fuzzy private set intersection with large hyperballs. Cryp- tology ePrint Archive, Paper 2024/330 (2024). https://eprint.iacr.org/2024/330
12. Chmielewski, L., Hoepman, J.: Fuzzy private matching (extended abstract). In: ARES,  IEEE Computer Society (2008)
13. Chor, B., Gilboa, N., Naor, M.: Private information retrieval by keywords. Cryp- tology ePrint Archive, Report 1998/003 (1998). https://eprint.iacr.org/1998/003
27. Ion, M., et al.: On deploying secure computing: private intersection-sum-with- cardinality. In: EuroS&P,  IEEE (2020)
31. Muﬀett, A.: Facebook: password hashing & authentication (2015). https://rwc. iacr.org/2015/program.html
32. Naor, M., Reingold, O.: Number-theoretic constructions of eﬃcient pseudo-random functions. In: 38th Annual Symposium on Foundations of Computer Science, Miami Beach, Florida, 19–22 October 1997,  IEEE Computer Society Press (1997). https://doi.org/10.1109/SFCS.1997.646134
1. Abraham, I., Asharov, G.: Gradecast in synchrony and reliable broadcast in asyn- chrony with optimal resilience, eﬃciency, and unconditional security. In: PODC 2022: ACM Symposium on Principles of Distributed Computing, Salerno, Italy, 25–29 July 2022,  ACM (2022)
4. Abraham, I., et al.: Communication complexity of Byzantine agreement, revisited. Distrib. Comput. 36(1), 3–28 (2023)
5. Abraham, I., Lewis-Pye, A.: Phase-king through the lens of gradecast: a sim- ple unauthenticated synchronous Byzantine agreement protocol. Decentralized Thoughts, Blog Post (2022). https://decentralizedthoughts.github.io/2022-06-09- phase-king-via-gradecast/
8. Ben-Or, M.: Another advantage of free choice: completely asynchronous agreement protocols (extended abstract). In: Proceedings of the Annual Symposium on Prin- ciples of Distributed Computing (PODC) (1983)
11. Berman, P., Garay, J.A., Perry, K.J.: Bit optimal distributed consensus. In: Baeza- Yates, R., Manber, U. (eds.) Computer Science. Springer, Cham (1992). https:// doi.org/10.1007/978-1-4615-3422-8 27
14. Chen, J.: Optimal error-free multi-valued Byzantine agreement. In: DISC 2021. LIPIcs, vol. 209, pp. 17:1–17:19. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik (2021)
15. Chor, B., Goldwasser, S., Micali, S., Awerbuch, B.: Veriﬁable secret sharing and achieving simultaneity in the presence of faults (extended abstract). In: 26th Annual Symposium on Foundations of Computer Science, Portland, Oregon, USA, 21–23 October 1985,  IEEE Computer Society (1985)
16. Coan, B.A., Welch, J.L.: Modular construction of nearly optimal byzantine agree- ment protocols. In: ACM Symposium on Principles of Distributed Computing (1989)
19. Dolev, D., Reischuk, R.: Bounds on information exchange for Byzantine agreement. In: ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, Ottawa, Canada, 18–20 August 1982,  ACM (1982)
20. Feldman, P., Micali, S.: Optimal algorithms for Byzantine agreement. In: Proceed- ings of the 20th Annual ACM Symposium on Theory of Computing (1988)
21. Feldman, P.N.: Optimal algorithms for Byzantine agreement. Ph.D. thesis, Mas- sachusetts Institute of Technology (1988)
22. Fischer, M.J., Lynch, N.A.: A lower bound for the time to assure interactive con- sistency. Inf. Process. Lett. 14, 183–186 (1982)
23. Fitzi, M., Garay, J.A.: Eﬃcient player-optimal protocols for strong and diﬀerential consensus. In: PODC (2003)
24. Goldreich, O., Petrank, E.: The best of both worlds: guaranteeing termination in fast randomized Byzantine agreement protocols. Inf. Process. Lett. 36(1), 45–49 (1990)
26. Kumaresan, R.: Broadcast and veriﬁable secret sharing: new security models and round optimal constructions. University of Maryland, College Park (2012)
27. Kushilevitz, E., Lindell, Y., Rabin, T.: Information-theoretically secure protocols and security under composition. In: Proceedings of the 38th Annual ACM Sympo- sium on Theory of Computing (2006)
28. Lamport, L., Shostak, R., Pease, M.: The Byzantine generals problem. ACM Trans. Program. Lang. Syst. 4, 382–401 (1982) Perfect (Parallel) Broadcast via Statistical VSS 339
29. Lindell, Y., Lysyanskaya, A., Rabin, T.: Sequential composition of protocols with- out simultaneous termination. In: Proceedings of the Twenty-First Annual ACM Symposium on Principles of Distributed Computing, PODC 2002, Monterey, Cal- ifornia, USA, 21–24 July 2002,  ACM (2002)
30. Nayak, K., Ren, L., Shi, E., Vaidya, N.H., Xiang, Z.: Improved extension protocols for byzantine broadcast and agreement. arXiv preprint arXiv:2002.11321 (2020)
33. Pease, M., Shostak, R., Lamport, L.: Reaching agreement in the presence of faults. J. ACM (JACM) 27, 228–234 (1980)
34. Rabin, M.O.: Randomized Byzantine generals. In: 2013 IEEE 54th Annual Sym- posium on Foundations of Computer Science (1983)
35. Rabin, T.: Robust sharing of secrets when the dealer is honest or cheating. J. ACM (JACM) 41(6), 1089–1109 (1994)
37. Zhu, J., Li, F., Chen, J.: Communication-eﬃcient and error-free gradecast with optimal resilience. In: 2023 IEEE International Symposium on Information Theory (ISIT),  (2023). https://doi.org/10.1109/ISIT54713.2023.10206579
0. For k ě 1, assume PrrEk´1s ď řk´1 i“1 1 |Ui|. It holds that PrrEks “ PrrEk|Ek´1sPrrEk´1s ` PrrEk|␣Ek´1sPrr␣Ek´1s ď PrrEk´1s ` PrrEk|␣Ek´1s “ PrrEk´1s ` Pr “ Ek ˇˇ p␣Ek´1q ^ Dk ‰ 0 ‰ PrrDk ‰ 0|␣Ek´1s ` Pr “ Ek ˇˇ p␣Ek´1q ^ Dk “ 0 ‰ PrrDk “ 0|␣Ek´1s ď PrrEk´1s ` Pr “ Ek ˇˇ p␣Ek´1q ^ Dk ‰ 0 ‰ ` Pr “ Ek ˇˇ p␣Ek´1q ^ Dk “ 0 ‰ . (42) It is left to bound Pr “ Ek ˇˇ p␣Ek´1q ^ Dk ‰ 0 ‰ and Pr “ Ek ˇˇ p␣Ek´1q ^ Dk “ 0 ‰ . Suppose Ek´1 does not occur and then we have either Di “ 0 for all 0 ď i ă k or D0 ` řk´1 j“1 DjXj “ 0. If Dk “ 0, we have either Di “ 0 for all 0 ď i ď k, or D0 ` řk j“1 DjXj “ D0 ` řk´1 j“1 DjXj ‰ 0, which means Ek does not occur. Therefore, we have Pr “ Ek ˇˇ p␣Ek´1q ^ Dk “ 0 ‰ “ 0. (43) 37 Otherwise, if Dk ‰ 0, we know Ek occurs if and only if D0 ` řk j“1 DjXj ‰
0. Since Xk is uniformly distributed over Uk independent of pD0, . . . , Dk, X1, . . . , Xk´1q given Dk ‰ 0 and Ek´1 does not occur, it holds that Pr “ Ek ˇˇ p␣Ek´1q ^ Dk ‰ 0 ‰ “ Pr « D0 ` kÿ j“1 DjXj “ 0 ˇˇ p␣Ek´1q ^ Dk ‰ 0 ﬀ “ Pr « Xk “ D0 ` řk´1 j“1 DjXj Dk ˇˇ p␣Ek´1q ^ Dk ‰ 0 ﬀ ď 1 |Ui| . (44) Therefore, from (42), (43), and (44), we have PrrEks ď PrrEk´1s ` 1 |Ui| ď kÿ i“1 1 |Ui| . Therefore, by induction, we have Pr « D i P t0, . . . , nu : Di ‰ 0 ^ D0 ` n ÿ j“1 DjXj “ 0 ﬀ “ PrrEns ď n ÿ i“1 1 |Ui|. [\ B Postponed Proofs from Section 4 B.1 Proof of Lemma 7 We prove the lemma by going through a serious of games. GameA 0 : This is OMUF-GGMA BS1 (Figure 5). GameA 1 : This is deﬁned in Figure 14 that only contains the dashed box. We introduce variables X, A1, Y1, . . . , AQS1, YQS1 in GameA 1 . Each variable is assigned a value, that is, X is assigned x, Ai is assigned ai, and Yi is assigned yi ¨x. The input to Φ is a polynomial P of variables X, tAi, YiuiPrQS1s over Zp instead of a single value v P Zp and the set Cur is a set of polynomials. Also, in Φ we check the equality of two polynomials by its evaluation on the assigned values, which is denoted by “eval (see Deﬁnition 1). Deﬁnition
1. For two ploynomial P and P 1 of the variables X1, . . . , Xn over a ﬁeld F, suppose each Xi is assigned with a value xi P F. We say P “eval P 1 if and only if PpX1 “ x1, . . . , Xn “ xnq “ P 1pX1 “ x1, . . . , Xn “ xnq. For convenience, we also have P “eval PpX1 “ x1, . . . , Xn “ xnq. It is easy to check that “eval is an equivalence relation over the polynomials of the variables X1, . . . , Xn. We ﬁrst show that the oracle Φ in GameA 1 is well-deﬁned, that is, for each query P to Φ, there exists at most one P 1 P Cur such that P “eval P
1. Suppose there exists P 1, P 2 P Cur such that P 1 ‰ P 2, P 1 “eval P “eval P 2. Suppose P 2 is added to Cur after P
1. Consider the query to Φ during which P 2 is added to Cur. Since P 1 is already in Cur when P 2 is added, we have P 1 ‰eval P 2, which yields a contradiction. Therefore, for each query to Φ, if there exists P 1 P Cur such that P “eval P 1, then P 1 is the unique polynomial in Cur such that P “eval P 1. We now show that the views of the adversary in Game0 and Game1 are identical. Deﬁne an intermediate game Game1 1 A such that it is identical to GameA 1 except each the polynomial P appear in the game is 38 Game GameA 1 , GameA 2 , Game1 2 A : p Ð |Gλ|; x Ð$ Z˚ p ; assign x to variable X sid Ð 0; ℓÐ 0; Iﬁn Ð H; Ξ Ð pq; T Ð pq Cur Ð H; L Ð H tpmk, σkqukPrℓ`1s Ð$ AΠ,S1,S2,Hpp, Φp1q, ΦpXqq If D k1 ‰ k2 such that pmk1, σk1q “ pmk2, σk2q then Return 0 If D k P rℓ` 1s such that y˚ k “ 0 or ck ‰ HpΦpsk ´ ck ¨ yk ¨ Xq } Φpyk ¨ Xq } miq where pck, sk, ykq “ σk then return 0 Return 1 Oracle ΦpPq : If DP 1 P Cur such that P “eval P 1 and P ‰L P 1 then abort game If DP 1 P Cur such that P “eval P 1 then Return ΞpP 1q If DP 1 P Cur such that P “L P 1 then Return ΞpP 1q ΞpPq Ð$ t0, 1ulogppqzΞpCurq Cur Ð Cur X tPu Return ΞpPq Oracle Πpξ, ξ1, bq : If DP, P 1 P Cur such that ξ “ ΞpPq and ξ1 “ ΞpP 1q then Return ΦpP ` p´1qbP 1q Else return K Oracle S1 : sid Ð sid ` 1 asid Ð$ Zp; ysid Ð$ Z˚ p sts sid Ð pasid, ysidq Assign asid to variable Asid Assign ysid ¨ x to varaible Ysid msg1 Ð pΦpAsidq, ΦpYsidqq Return psid, msg1q Oracle S2pi, ciq : If i R rsidszIﬁn then return K pai, yiq Ð sts i si Ð ai ` ci ¨ yi ¨ x R1 Ð Ai ` ciYi ´ si R2 Ð Yi ´ yiX L Ð L Y tR1, R2u msg2 Ð psi, yiq Iﬁn Ð Iﬁn Y tiu ℓÐ ℓ` 1 Return msg2 Oracle Hpstrq : If Tpstrq “ K then Tpstrq Ð$ Zp Return Tpstrq Fig.
14. The deﬁnition for GameA 1 , GameA 2 , and Game1 2 A, where GameA 1 only contains the dashed box, GameA 2 contains all but the gray box, and Game1 2 A contains all but the dashed box. replaced by its evaluation value PpX “ x, A1 “ a1, Y1 “ y1 ¨x, . . . , Asid “ asid, Ysid “ ysid ¨xq. It is clear that Game1 1 A is identical to GameA 0 . Also, since in the oracle Φ in GameA 1 , a polynomial P is considered equal or not equal to another polynomials by its evaluation value, the view of the adversary in Game1 and Game1 1 are identical. Thus, we know the views of the adversary in Game0 and Game1 are identical, which implies PrrGameA 0 “ 1s “ PrrGameA 1 “ 1s . (45) GameA 2 : This is deﬁned in Figure 14 by ignoring the graybox. A set L is introduced to record the information leaked to the adversary by S2. For the query pi, ciq to S2, polynomials R1 “ Ai `ciYi ´si and R2 “ Yi ´yiX are added to L. Suppose L is also recorded in GameA 1 . In GameA 1 , deﬁne the event E1 as after an query P to Φ is made, DP 1 P Cur such that P “eval P 1 and P ‰L P 1 . Then, GameA 2 is identical to GameA 1 except it aborts when E1 occurs and we have PrrGameA 1 “ 1s ď PrrGameA 2 “ 1s ` PrrE1s , (46) To bound PrrE1s, for each j P rQΦs, we denote the event E1,j in GameA 1 as during the j-th query to Φ DP 1 P Cur such that Pj “eval P 1 and Pj ‰L P 1 . 39 Then, we have E1 “ Ž jPrQΦs E1,j. Denote E1 1,j :“ E1,j Ź iPrjsp␣E1,iq. We now bound PrrE1 1,js for each j P rQΦs. We now ﬁx a certain j P rQΦs. Consider the step when the j-th query to Φ is made during GameA 1 . Denote the transcripts between the oracles and adversarys when the j-th query to Φ is made as πj, which contains Φp1q, ΦpXq, and all the inputs and outputs of the queries to S1, S2, Π, and H made before the j-th query to Φ. For a certain transcript πj “ ∆, for 1 ď k ď j, denote the k-th query to Φ in ∆as P ∆ k . From the transcript ∆, one can compute the set Iﬁn, Cur, and L at the step when the j-th query to Φ is been made. Denote them by I∆ ﬁn, Cur∆, and L∆. For each i P I∆ ﬁn, denote the input and output of the query to the S2 for the session i in the transcript ∆as c∆ i and ps∆ i , y∆ i q. Also, from the transcript πj, one can tell whether E1,k occurs or not for k P rj ´ 1s, since the event E1,k occurs if and only if Pk ‰L P 1 for all P 1 P Cur but Pk is not added to Cur. Denote the value of sid when the j-th query to Φ is made as sid∆. Denote Tj as the set of all transcripts ∆such that Prrπj “ ∆s ą 0 and none of tE1,kukPrjs occurs given πj “ ∆. We just need to bound PrrE1 1,j|πj “ ∆s for each ∆P Tj. We now ﬁx a certain ∆P Tj. For any polynomial P, denote the event FP as P “eval Pj and P ‰L Pj. Then we know E1 1,j implies one of tFP uP PCur∆occurs and we have PrrE1 1,j|πj “ ∆s ď Pr « ł P PCur∆ FP |πj “ ∆ ﬀ . Therefore, it is left to bound PrrFP s for each P P Cur∆. We now ﬁx a certain ˆP P Cur∆. Since P ∆ j and L∆are ﬁxed in ∆, we can directly check whether ˆP “L∆P ∆ j or not. If ˆP “L∆P ∆ j , then we have PrrF ˆ P s “
0. Therefore, we can assume ˆP ‰L∆P ∆ j . Then, we only need to bound the probability of ˆP “eval P ∆ j . Since we ﬁx πj “ ∆, the only randomness here is the values assigned to the random variables X, tAi, YiuiPrsid∆s. Denote the values as ⃗η :“ px, a1, y1 ¨x, . . . , asid∆, ysid∆¨xq P Z1`2sid∆ p , where x, tai, yiuiPrsid∆s are random variables sampled in the game, and we have P “eval PpX “ η1, tAi “ η2i, Yi “ η2i`1uiPrsid∆sq. To bound Prr ˆP “eval P ∆ j |πj “ ∆s, we ﬁrst introduce Lemma 15 below. Then the proof structure can be described as follows. We ﬁrst deﬁne a sequence of polynomials D0, D1, . . . , Dm, B1, . . . , Bq`1 over variables X, tAi, YiuiPrsid∆s such that Bq`1 :“ ˆP ´ P ∆ j . Then, we try to apply Lemma 15 to bound the probability by showing η is uniformly distributed over C, ZeropBq`1q X C ‰ H, and Bq`1 R Spanpt1, B1, . . . , Bquq given πj “ ∆, where C is deﬁned in Lemma 15. Lemma 15 (Lemma 1 in [BFP21]). Let D1, . . . , Dm, B1, . . . , Bq`1 be polynomials in ZprX1, . . . , Xns of degree
1. Let C :“ ¨ ˝ č iPrqs ZeropBiq ˛ ‚z ¨ ˝ ď iPrms ZeropDiq ˛ ‚ , where ZeropPq means the zero set of P. Assume ZeropBq`1q X C ‰ H and Bq`1 R Spanpt1, B1, . . . , Bquq. If ⃗x is picked uniformly at random from C then p ´ m p2 ď PrrBq`1p⃗xq “ 0s ď 1 p ´ m . Let m :“ sid∆` 1 ` |Cur∆|p|Cur∆´ 1|q. Denote D1 :“ X and Di`1 :“ Yi for i P rsid∆s. For each P, P 1 P Cur∆such that P ‰ P 1, denote DP,P 1 :“ P ´ P
1. We can relable tDP,P 1uP,P 1PCur∆,P ‰P 1 to Dsid∆`2, . . . , Dm. Let q :“ 2|I∆ ﬁn|. For each i P I∆ ﬁn, denote Bpi,1q :“ Ai ` c∆ i Yi ´ s∆ i , Bi,2 :“ Yi ´ y∆ i X . We can relabel tBpi,1q, Bpi,2quiPI∆ fin to B1, . . . , Bq and denote Bq`1 :“ ˆP ´ P ∆ j . Here one thing to notice is that we have L∆“ tB1, . . . , Bqu. 40 Denote C :“ ´Ş iPrqs ZeropBiq ¯ z ´Ť iPrms ZeropDiq ¯ and we have the following claim. The proof of the claim is deferred to
3. Ahlswede, R., G´acs, P.: Spreading of sets in product spaces and hypercontraction of the Markov operator. Ann. Probab. 4, 925–939 (1976)
5. Beigi, S., Gohari, A.: On the duality of additivity and tensorization. In: 2015 IEEE International Symposium on Information Theory (ISIT),  IEEE (2015)
9. Bogdanov, A., Mossel, E.: On extracting common random bits from correlated sources. IEEE Trans. Inf. Theory 57(10), 6351–6355 (2011)
10. Borell, C.: Positivity improving operators and hypercontractivity. Mathematische Zeitschrift 180(3), 225–234 (1982)
13. Chan, S.O., Mossel, E., Neeman, J.: On extracting common random bits from correlated sources on large alphabets. IEEE Trans. Inf. Theory 60(3), 1630–1637 (2014)
15. Cr´epeau, C., Kilian, J.: Achieving oblivious transfer using weakened security assumptions (extended abstract). In: 29th FOCS,  IEEE Computer Soci- ety Press (October 1988)
18. De, A., Mossel, E., Neeman, J.: Non interactive simulation of correlated distribu- tions is decidable. In: Czumaj, A. (ed.) 29th SODA,  ACM-SIAM (January 2018)
19. Dinur, I., Filmus, Y., Harsha, P.: Low degree almost Boolean functions are sparse juntas. Electron. Colloquium Comput. Complex. 24, 180 (2017)
20. Dodis, Y., Ostrovsky, R., Reyzin, L., Smith, A.D.: Fuzzy extractors: how to gen- erate strong keys from biometrics and other noisy data. SIAM J. Comput. 38(1), 97–139 (2008)
21. G´acs, P., K¨orner, J.: Common information is far less than mutual information. Probl. Control Inf. Theory 2(2), 149–162 (1973)
23. Gertner, Y., Kannan, S., Malkin, T., Reingold, O., Viswanathan, M.: The rela- tionship between public key encryption and oblivious transfer. In: 41st FOCS,  IEEE Computer Society Press (November 2000) Secure Non-interactive Simulation: Feasibility and Rate 795
24. Ghazi, B., Kamath, P., Raghavendra, P.: Dimension reduction for polynomials over Gaussian space and applications. In: Servedio, R.A. (ed.) 33rd Computational Complexity Conference, CCC 2018, June 22–24, 2018, San Diego, CA, USA, volume 102 of LIPIcs, pp. 28: 1–28:
37. Schloss Dagstuhl - Leibniz Center for ”u r Computer Science (2018)
25. Ghazi, B., Kamath, P., Sudan, M.: Decidability of non-interactive simulation of joint distributions. In: Dinur, I. (ed.) 57th FOCS,  IEEE Computer Society Press (October 2016)
26. Goldreich, O., Micali, S., Wigderson, A.: How to play any mental game or a com- pleteness theorem for protocols with honest majority. In: Aho, A. (ed.) 19th ACM STOC,  ACM Press (May 1987)
27. Kamath, S., Anantharam, V.: Non-interactive simulation of joint distributions: the hirschfeld-gebelein-r´enyi maximal correlation and the hypercontractivity rib- bon. In: 2012 50th Annual Allerton Conference on Communication, Control, and Computing (Allerton),  IEEE (2012)
28. Kamath, S., Anantharam, V.: On non-interactive simulation of joint distributions. IEEE Trans. Inf. Theory 62(6), 3419–3435 (2016)
30. Kilian, J.: More general completeness theorems for secure two-party computation. In: 32nd ACM STOC,  ACM Press (May 2000)
31. Kindler, G.: Property Testing PCP. Ph.D. thesis, Tel-Aviv University (2002)
32. Kindler, G., Safra, S.: Noise-resistant Boolean functions are juntas. preprint (2002)
34. MacWilliams, F.J., Sloane, N.J.A.: The Theory of Error Correcting Codes, vol. 16. Elsevier, Amsterdam (1977)
35. Mahmoody, M., Maji, H.K., Prabhakaran, M.: Limits of random oracles in secure computation. In: Naor, M. (ed.) ITCS 2014,  ACM (January 2014)
39. Mossel, E.: Gaussian bounds for noise correlation of functions and tight analysis of long codes. In: 49th FOCS,  IEEE Computer Society Press (October 2008)
40. Mossel, E., O’Donnell, R.: Coin ﬂipping from a cosmic source: on error correction of truly random bits. Random Struct. Algorithms 26(4), 418–436 (2005)
41. Mossel, E., O’Donnell, R., Regev, O., Steif, J.E., Sudakov, B.: Non-interactive correlation distillation, inhomogeneous Markov chains, and the reverse Bonami- Beckner inequality. Israel J. Math. 154(1), 299–336 (2006) 796 H. Amini Khorasgani et al.
42. Mossel, E., Oleszkiewicz, K., Sen, A.: On reverse hypercontractivity. Geom. Funct. Anal. 23(3), 1062–1097 (2013)
43. Nair, C., Wang, Y.N.: Reverse hypercontractivity region for the binary erasure channel. In: 2017 IEEE International Symposium on Information Theory (ISIT), IEEE (2017)
46. O’Donnell, R.: Analysis of Boolean Functions. Cambridge University Press, Cam- bridge (2014)
47. Rabin, M.O.: How to exchange secrets by oblivious transfer. Technical Memo TR- 81 (1981)
49. Witsenhausen, H.S.: On sequences of pairs of dependent random variables. SIAM J. Appl. Math. 28(1), 100–113 (1975)
50. Wyner, A.: The common information of two dependent random variables. IEEE Trans. Inf. Theory 21(2), 163–179 (1975)
52. Yao, A.C.-C.: Protocols for secure computations (extended abstract). In: 23rd FOCS,  IEEE Computer Society Press (November 1982)
53. Yin, Z., Park, Y.: Hypercontractivity, maximal correlation and non-interactive sim- ulation (2014)
4. Bellare, M., Canetti, R., Krawczyk, H.: Pseudorandom functions revisited: the cas- cade construction and its concrete security. In: 37th FOCS, Burlington, Vermont, IEEE Computer Society Press (1996). https://doi.org/10.1109/SFCS. 1996.548510
12. Camenisch, J., Lehmann, A., Neven, G., Samelin, K.: UC-secure non-interactive public-key encryption. In: Köpf, B., Chong, S. (eds.) CSF 2017 Computer Security Foundations Symposium, Santa Barbara, CA, USA,  IEEE Computer Society Press (2017). https://doi.org/10.1109/CSF.2017.14
13. Canetti, R., Feige, U., Goldreich, O., Naor, M.: Adaptively secure multi-party computation. In: 28th ACM STOC, Philadelphia, PA, USA,  ACM Press (1996). https://doi.org/10.1145/237814.238015
15. Cramer, R., Shoup, V.: Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM J. Comput. 33(1), 167–226 (2003)
17. Goldreich, O., Goldwasser, S., Micali, S.: How to construct random functions. J. ACM 33(4), 792–807 (1986)
12. Bernstein, D.J.: Extending the Salsa20 nonce. In: SKEW 2011 (Symmetric Key Encryption Workshop 2011) (2011). https://doi.org/10.1109/SP46215.2023. 10179342. See the authors’ website or http://skew2011.mat.dtu.dk/program.html
26. Doosti, M., Delavar, M., Kasheﬁ, E., Arapinis, M.: A uniﬁed framework for quan- tum unforgeability. CoRR abs/2103.13994 (2021). https://arxiv.org/abs/2103. 13994
39. Majenz, C., Manfouo, C.M., Ozols, M.: Quantum-access security of the Winternitz one-time signature scheme. In: Tessaro, S. (ed.) ITC 2021. LIPIcs, vol. 199, pp. 21:1–21:22. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik (2021). https://doi. org/10.4230/LIPICS.ITC.2021.21
44. Zhandry, M.: How to construct quantum random functions. In: FOCS 2012, Octo- ber 2012,  IEEE Computer Society Press (2012). https://doi.org/10. 1109/FOCS.2012.37
1. Becker, A., Ducas, L., Gama, N., Laarhoven, T.: New directions in nearest neigh- bor searching with applications to lattice sieving. In: Krauthgamer, R. (ed.) 27th SODA,  ACM-SIAM (2016). https://doi.org/10.1137/1.9781611974331. ch2
4. Carrier, K.: Recherche de presque-collisions pour le d´ecodage et la reconnaissance de codes correcteurs. Ph.D. thesis, Sorbonne universit´e (2020) Asymptotics and Improvements of Sieving for Codes 179
6. Cooper, C.: On the distribution of rank of a random matrix over a ﬁnite ﬁeld. Random Struct. Algorithms 17(3–4), 197–212 (2000)
8. Dubiner, M.: Bucketing coding and information theory for the statistical high- dimensional nearest-neighbor problem. IEEE Trans. Inf. Theory 56(8), 4166–4179 (2010)
12. Esser, A., K¨ubler, R., Zweydinger, F.: A faster algorithm for ﬁnding closest pairs in hamming metric. In: Bojanczyk, M., Chekuri, C. (eds.) 41st IARCS Annual Confer- ence on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2021, December 15-17, 2021, Virtual Conference. LIPIcs, vol. 213, pp. 20:1–20:21. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik (2021).https://doi. org/10.4230/LIPIcs.FSTTCS.2021.20
15. Fincke, U., Pohst, M.: A procedure for determining algebraic integers of given norm. In: van Hulzen, J.A. (ed.) Computer Algebra,  (1983)
18. Indyk, P., Motwani, R.: Approximate nearest neighbors: towards removing the curse of dimensionality. In: 30th ACM STOC,  ACM Press (1998). https://doi.org/10.1145/276698.276876
19. Kannan, R.: Improved algorithms for integer programming and related lattice prob- lems. In: Proceedings of the Fifteenth Annual ACM Symposium on Theory of Com- puting,  STOC ’83 (1983). https://doi.org/10.1145/800061.808749 180 L. Ducas et al.
28. Pagh, R.: Locality-sensitive hashing without false negatives. In: Krauthgamer, R. (ed.) 27th SODA,  ACM-SIAM (2016). https://doi.org/10.1137/1. 9781611974331.ch1
29. Prange, E.: The use of information sets in decoding cyclic codes. IRE Trans. Inf. Theory 8(5), 5–9 (1962)
2. Aaronson, S.: The equivalence of sampling and searching. Theory Comput. Syst. 55(2), 281–298 (2013)
4. Aharonov, D., Ben-Or, M., Eban, E., Mahadev, U.: Interactive proofs for quantum computations. arXiv:1704.04487 (2017)
5. Aharonov, D., Van Dam, W., Kempe, J., Landau, Z., Lloyd, S., Regev, O.: Adia- batic quantum computation is equivalent to standard quantum computation. SIAM Rev. 50(4), 755–787 (2008)
6. Alagic, G., Dulek, Y., Schaﬀner, C., Speelman, F.: Quantum fully homomorphic encryption with veriﬁcation (2017)
8. Arute, F., Arya, K., Babbush, R., et al.: Quantum supremacy using a pro- grammable superconducting processor. Nature 574(7779), 505–510 (2019)
9. Bartusek, J.: Secure quantum computation with classical communication (2021)
10. Bellare, M., Impagliazzo, R., Naor, M.: Does parallel repetition lower the error in computationally sound protocols? In: 38th Annual Symposium on Foundations of Computer Science, FOCS 1997, Miami Beach, Florida, USA, 19–22 October 1997, (1997)
11. Biamonte, J.D., Love, P.J.: Realizable Hamiltonians for universal adiabatic quan- tum computers. Phys. Rev. A 78, 012352 (2008)
13. Broadbent, A., Fitzsimons, J., Kasheﬁ, E.: Universal blind quantum computation. In: 2009 50th Annual IEEE Symposium on Foundations of Computer Science,  (2009)
16. Chung, K.-M.: Eﬃcient parallel repetition theorems with applications to security ampliﬁcation. PhD thesis, Harvard University (2011)
17. Chung, K.-M., Lee, Y., Lin, H.-H., Wu, X.: Constant-round blind classical veriﬁ- cation of quantum sampling (2021)
19. Cr´epeau, C., Gottesman, D., Smith, A.: Secure multi-party quantum computa- tion. In: Proceedings of the Thirty-Fourth Annual ACM Symposium on Theory of Computing - STOC 2002. ACM Press (2002)
21. Fitzsimons, J.F., Hajduˇsek, M., Morimae, T.: Post hoc veriﬁcation of quantum computation. Phys. Rev. Lett. 120, 040501 (2018)
22. Fitzsimons, J.F., Kasheﬁ, E.: Unconditionally veriﬁable blind quantum computa- tion. Phys. Rev. A 96, 012303 (2017)
24. Gheorghiu, A., Vidick, T.: Computationally-secure and composable remote state preparation. In: FOCS,  (2019)
26. Hayashi, M., Morimae, T.: Veriﬁable measurement-only blind quantum computing with stabilizer testing. Phys. Rev. Lett. 115(22), 220502 (2015)
27. Kempe, J., Kitaev, A., Regev, O.: The complexity of the local Hamiltonian prob- lem. SIAM J. Comput. 35(5), 1070–1097 (2006)
28. Kitaev, A.Y., Shen, A., Vyalyi, M.N.: Classical and Quantum Computation. Grad- uate Studies in Mathematics. American Mathematical Society (2002)
29. Mahadev, U.: Classical homomorphic encryption for quantum circuits. In: 2018 IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS) (2018)
30. Mahadev, U.: Classical veriﬁcation of quantum computations. In: 2018 IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS) (2018)
31. Marriott, C., Watrous, J.: Quantum Arthur-Merlin games. Comput. Complex. 14(2), 122–152 (2005). https://doi.org/10.1007/s00037-005-0194-x
32. Morimae, T., Nagaj, D., Schuch, N.: Quantum proofs can be veriﬁed using only single-qubit measurements. Phys. Rev. A 93, 022326 (2016)
35. Reichardt, B.W., Unger, F., Vazirani, U.: Classical command of quantum systems. Nature 496(7746), 456 (2013)
36. Shepherd, D., Bremner, M.J.: Temporally unstructured quantum computation. Proc. R. Soc. A. 465, 1413–1439 (2009)
37. Shor, P.W.: Algorithms for quantum computation: discrete logarithms and factor- ing. In: Proceedings 35th Annual Symposium on Foundations of Computer Science, (1994)
38. Takeuchi, Y., Morimae, T.: Veriﬁcation of many-qubit states. Phys. Rev. X 8(2), 021060 (2018)
2. A high-level overview of how to implement the MILP-based method with an SAT/SMT-based method and how to overcome more contradictions in the differential characteristics of SHA-2 in is given Section
3. Then, we show how to find the differential characteristics to mount the (SFS/FS) collisions for SHA-2 in Section
4. Finally, we conclude this paper in Section 5. 2 Preliminaries 2.1 Notations For a better understanding of this paper, we introduce the following notations.
1. ⊞and ⊟represent modulo addition and modulo subtraction on 32/64 bits, respectively.
2. ≫, ≫, ⊕, ¬, ∨and ∧represent shift right, rotate right, exclusive or, not, or, and and, respectively.
3. x[i] denotes the i-th bit of x and x[0] is the least significant bit.
4. δx denotes the modular difference, i.e., δx = x′ ⊟x.
5. ∆x denotes the signed difference between x′ and x. We use the same notation as in [21,23], i.e., ∆x[i] =                n (x[i] = 0, x′[i] = 1) u (x[i] = 1, x′[i] = 0) = (x[i] = x′[i]) 0 (x[i] = x′[i] = 0) 1 (x[i] = x′[i] = 1) (1)
6. M = (m0, m1, . . . , m15) and M ′ = (m′ 0, m′ 1, . . . , m′ 15) represent two message blocks. Definition 1.
[23] The signed difference ∆x is said to be an expansion of the modular difference δx only when ∆x corresponds to the modular difference δx. Definition 2.
[23] The hamming weight of the signed difference ∆x is denoted by H(∆x) and H(∆x) is the number of indices i such that ∆x[i] ∈{n, u}. For example, let ∆x0 = [==== nu== ==== ==== ==== ==== ==== ====], ∆x1 = [==== =n== ==== ==== ==== ==== ==== ====]. Then, both ∆x0 and ∆x1 are the expansions of δx = 226. Moreover, we have H(∆x0) = 2 and H(∆x1) =
1. The state update transformation of SHA-2. Both SHA-256 and SHA-512 utilize the same Boolean functions IF and MAJ, as defined below: IF(x, y, z) = (x ∧y) ⊕(x ∧z) ⊕z, MAJ(x, y, z) = (x ∧y) ⊕(x ∧z) ⊕(y ∧z). However, the linear functions Σ0 and Σ1 are different for SHA-256 and SHA-512. For SHA-256, they are defined below: Σ0(x) = (x ≫2) ⊕(x ≫13) ⊕(x ≫22), Σ1(x) = (x ≫6) ⊕(x ≫11) ⊕(x ≫25). For SHA-512, they are defined below: Σ0(x) = (x ≫28) ⊕(x ≫34) ⊕(x ≫39), Σ1(x) = (x ≫14) ⊕(x ≫18) ⊕(x ≫41). After the last step of the state update transformation, the previous chaining value is added to the output of the state update. The result of this feed-forward sum is the chaining value h: h = (A63 ⊞A−1, . . . , A60 ⊞A−4, E63 ⊞E−1, . . . , E60 ⊞E−4). On finding (FS/SFS) collisions. Denote the compression function of SHA-2 by hi = H(hi−1, Mi). To find a collision with j message blocks, we need to find (M1, . . . , Mj) and (M ′ 1, . . . , M ′ j) ̸= (M1, . . . , Mj) such that hj = h′ j where h′ i = H(h′ i−1, M ′ i) and h0 = h′ 0 is a predefined constant. In most cases, only Mj ̸= M ′ j is required and we have Mk = M ′ k for 1 ≤k < j. To find SFS collisions, we need to find H(h, M) = H(h, M ′) where M ̸= M ′ and h can be an arbitrary value. To find FS collisions, we need to find H(h, M) = H(h′, M ′) where M ̸= M ′ and (h, h′) can be arbitrary values. 7 2.3 Previous Methods to Search for Differential Characteristics Almost all effective collision attacks on the MD-SHA hash family rely on Wang et al.’s techniques [37,38,39]. One of the most important steps is to find a collision- generating differential characteristic. For this purpose, there are three methods in the literature, as summarized below. – Hand-crafted method: This remarkable work was first done by Wang et al. in their ground-breaking works on MD4 [37], MD5 [39], SHA-0 [40], and SHA-1 [38]. However, for complex designs like SHA-256 and RIPEMD-160, finding such differential characteristics for a large number of steps by hand is almost impossible, or at least considerably time-consuming. – Ad-hoc heuristic search tools: De Cannière and Rechberger developed the first heuristic search tool for this problem based on the guess-and- determine (GnD) technique, and successfully applied it to SHA-1 [4]. Sub- sequently, this heuristic search tool were further developed and it has been applied to many hash functions like RIPEMD-128, RIPEMD-160, SHA-256, and SHA-512 [6,8,14,18,19,22,24,25,26,27,28]. However, the implementation of this GnD-based tool is not open-source. Although Stevens made his tools for MD5 and SHA-1 [34,35,36] open-source, it requires a significant amount of work to tweak them for SHA-2 because contradictions much more easily occur in the differential characteristics of SHA-2, and no existing tools for SHA-2 are based on this method. – Off-the-shelf solvers: The method was first explored in
[31] with SAT solvers after Wang et al.’s attacks and it was later also applied to SHA-1 in [35]. The main idea is to construct a model to describe two parallel in- stances of the value transitions. A new MILP-based method proposed by Liu et al.
[23] works quite well for RIPEMD-160. 3 SAT/SMT-based Tools for the MD-SHA Hash Family The first SAT-based method to find collision-generating differential characteris- tics was proposed in 2006 [31], but the model is to simply describe two parallel instances of the value transitions. To efficiently capture the information of the signed difference propagation, the MILP-based method was proposed in [23]. Although the authors of
[23] with an SAT/SMT-based method, and how to detect more contradictions in SHA-2 characteristics. Then, we demonstrate how to utilize our tools to find suitable differential characteristics to significantly improve the (SFS) collision attacks on SHA-2. 8 For the MILP-based method in [23], the constraints are already in Conjunc- tive Normal Form (CNF) due to the usage of the software Friday, which can output the minimized CNF for a given truth table with the Quine-McCluskey (QM) algorithm. However, they choose to further convert CNF into linear in- equalities in order to use the solver Gurobi [23]. In this sense, we can not claim any novelty for how to re-implement the propagation of signed difference tran- sitions with SAT/SMT. To make this paper self-contained, we briefly describe the idea to model the signed difference propagation with SAT/SMT. Note that when applying it to searching for valid SHA-2 characteristics, nontrivial addi- tional techniques are required, as can be seen later in our detailed description of the search strategy. For the MD-SHA hash family, it can be observed that in their round func- tions, there are three basic operations: – modular addition; – logic shift; – Boolean functions. Hence, we only describe how to describe the signed difference transitions through the modular addition and Boolean functions. For the logic shift, it does affect the model for RIPEMD-160 as shown in [23]. However, in the case of SHA-2, there is no such problem and it only affects the order of the variables. Hence, we simply omit it in this section. Since we will target both SHA-256 and SHA-512, and their state sizes are 32 and 64 bits, respectively, to make the description of the model general, we treat the state size as n bits, i.e., the modular addition is within modulo 2n. 3.1 SAT/SMT Models for the Signed Difference Transitions Similar to [23], we use 2 binary variables (v, d) to describe the signed difference. Specifically, (0, 0), (0, 1) and (1, 1) correspond to [=], [n] and [u], respectively, while we always exclude (1, 0) as it carries the same information as (0, 0). For the n-bit signed difference ∆x, throughout this paper, the signed difference at the i-th (0 ≤i ≤n −1) bit is always represented by (xv[i], xd[i]). For example, if n = 5 and ∆x = [=u==n], we have (xv[0], xd[0]) = (0, 0), (xv[1], xd[1]) = (1, 1), (xv[2], xd[2]) = (0, 0), (xv[3], xd[3]) = (0, 0), (xv[4], xd[4]) = (0, 1). Modelling the modular addition. As explained in [23], given the signed difference ∆x and ∆y, it is sufficient to pick only 1 signed difference ∆z to describe the modular difference δz = δx ⊞δy. To achieved this, the intermediate variable ∆c with ∆c[0] = [=] is introduced and the propagation rules for (∆x[i], ∆y[i], ∆c[i]) Add −→(∆z[i], ∆c[i + 1]) 9 Table
2. The propagation rules for (∆x[i], ∆y[i], ∆c[i]) Add −→(∆z[i], ∆c[i + 1]) in [23] [=== →==], [==n →n=], [==u →u=], [=n= →n=], [=u= →u=], [=nn →=n], [=un →==], [=nu →==], [=uu →=u], [n== →n=], [u== →u=], [n=n →=n], [u=n →==], [n=u →==], [u=u →=u], [nn= →=n], [nun →n=], [unn →n=], [nnu →n=], [uun →u=], [unu →u=], [nuu →u=], [uuu →uu]. are shown in Table 2, where 0 ≤i ≤n −1. With the above method to describe the signed difference, there are 27 possible values for (xv[i], xd[i], yv[i], yd[i], cv[i], cd[i], zv[i], zd[i], cv[i + 1], cd[i + 1]) based on Table
[23] introduce a model to describe the expan- sions of the modular difference. Given one ∆z, the aim is to find all possible ∆ξ such that δξ = δz, i.e., ∆ξ and ∆z correspond to the same modular difference. To achieve this, as in [23], an intermediate variable ∆c is introduced and there are two methods to model it, as shown in Table 3. Table
3. Two methods to describe the propagation rules for the expansion of modular difference [23] Method 1 [nn →=n], [uu →=u], [nu →==], [un →==], [n= →n=], [n= →un], [u= →u=], [u= →nu], (∆z[i], ∆c[i]) Exp −→(∆ξ[i], ∆c[i + 1]) [=n →n=], [=n →un], [=u →u=], [=u →nu], [== →==]. Method 2 [=un →n], [=nn →=], [=uu →=], [=nu →u], [u=n →=], [n=n →n], [u=u →u], [n=u →=], (∆ξ[i], ∆z[i], ∆c[i]) Exp −→(∆c[i + 1]) [nu= →n], [nn= →=], [uu= →=], [un= →u], [=== →=]. 10 Similarly, based on the above way to describe the signed difference and using the software LogicFriday, the corresponding CNF to describe the constraints on (zv[i], zd[i], cv[i], cd[i], ξv[i], ξd[i], cv[i + 1], cd[i + 1]) for Method 1 can be obtained, which is denoted by CExp(i). The complete model for the expansion of the modular difference is thus CExp(i) for 0 ≤i ≤n −1 and (cv[0], cd[0]) = (0, 0) for Method 1. In the same way, we can also obtain the corresponding CNF denoted by C′ Exp(i) to describe the constraints on (ξv[i], ξd[i], zv[i], zd[i], cv[i], cd[i], cv[i + 1], cd[i + 1]) for Method
2. The complete model for the expansion of the modular difference is thus C′ Exp(i) for 0 ≤i ≤n −1 and (cv[0], cd[0]) = (0, 0) for Method 2. For convenience, we denote the model for the expansions of the modular addition in Method 1 and Method 2 by CExp(∆z, ∆ξ, ∆c) and C′ Exp(∆z, ∆ξ, ∆c). Modelling the vectorial Boolean functions w = f(x, y, z) [23]. In SHA-2, there are some vectorial Boolean functions, i.e., f can be XOR, IF or MAJ where XOR(x, y, z) = x ⊕y ⊕z. Note that σ0, σ1, Σ0 and Σ1 in SHA-2 are basically the same as XOR. Generally speaking, we can have w[i] = fi(x[i], y[i], z[i]) where fi is a Boolean function F3 2 7→F2 and 0 ≤i ≤n −1. As described in [23], there are two models for (fi)0≤i≤n−1 : (i) the fast filtering model; (ii) the full model. For the fast filtering model, we first need to build a table to include all valid propagation rules for (∆x[i], ∆y[i], ∆z[i], ∆w[i]) and then obtain the correspond- ing valid values for (xv[i], xd[i], yv[i], yd[i], zv[i], zd[i], wv[i], wd[i]). Finally, LogicFriday is used to obtain the corresponding CNF for the constraints on this tuple. For the full model, we need to involve both the signed difference and bit values. Specifically, the first step is to list all possible propagation rules for (∆x[i], ∆y[i], ∆z[i], ∆w[i], x[i], y[i], z[i]), where (x[i], y[i], z[i]) can make the signed difference transition (∆x[i], ∆y[i], ∆z[i]) fi −→∆w[i] hold with probability
4. By our procedure, this differential characteristic can be kept as sparse as possible and hence it is expected to be valid. Remark
2. Our strategy to search for a concrete 39-step differential character- istic is different from the GnD technique in
[6] because we first minimize the Hamming weight of (∆Wi, ∆Ai) and then search the solution under such con- straints. However, there is no such a minimization procedure when searching for the differential characteristic in 39-step SHA-512 in [6]. Without this strategy, the differential characteristic may be dense and there is a high chance that it is invalid, which may somehow explain why the technique in
[6] failed for 39-step SHA-256. 15 Message modification. As the differential characteristic is still relatively dense, we could not ensure that there must exist a conforming message pair. To verify this, we first extract all the constraints on (Ai, Ei)−4≤i≤22 and (Wi)0≤i≤38 for this differential characteristic. Then add these constraints to the SAT/SMT model for the value transitions of SHA-256, and solve the model to find a solu- tion of these variables. We succeed in finding a practical SFS colliding message pair for 39-step SHA-256 in 120 seconds with 26 threads, as shown in Table 5. unknown difference cancel difference zero difference (b) -4 -1 0 15 16 17 18 10 14 IVA IVE Ai Ei Wi 5 11 9 20 25 30 -4 -1 0 10 8 9 16 17 18 19 22 23 24 25 26 27 28 31 32 33 11 15 12 38 Ai Ei Wi (a) IVA IVE Fig.
[27] to convert SFS collisions into collisions is described below: Step 1: Find 2ℓsolutions of (Ai)−3≤i≤12, (Ei)1≤i≤12 and (Wi)5≤i≤12 that satisfy the differential conditions on steps 5−12. Store them in a table denoted by TAB1. 16 Table
4. The differential characteristic for 39 steps of SHA-256 i ∆Ai ∆Ei ∆Wi -4 ================================ ================================ -3 ================================ ================================ -2 ================================ ================================ -1 ================================ ================================ 0 ================================ ================================ ================================ 1 ================================ ================================ ================================ 2 ================================ ================================ ================================ 3 ================================ ================================ ================================ 4 ================================ ================================ ================================ 5 ================================ ================================ ================================ 6 ================================ ===0============================ ================================ 7 ================================ ===1=========11=====11======0=== ================================ 8 ===u============================ unnn1=1110=0=0101==00011==11110= ===u============================ 9 ==============n=u====u======n=== 010n0n0111010nu01001un011n10n=10 ======n===u==========u========== 10 ================================ 0101u1n=1n0n010=u0=11nuu=1u00=n1 ===n============================ 11 ================================ =100010000=0101=0===0010=10=1=0= =======nn=======n===n===nn==uu=n 12 ================================ =unn010000=1000011=00011==0=101= =============u=======nn========= 13 ================================ 10110nuuuuuuuuu0u101un000010n111 ================================ 14 ================================ =111=0000000000=0=1=001111111=1= ================================ 15 ============================n=== 11001101101000000001nuuuuuuuu001 ================================ 16 =======u=u=======u============== 010100unu000001001u1000110unn=n1 ======n===u==========u========== 17 ================================ 1100111u00nn=100110=u1u00unn000n ===n============================ 18 ===n============================ uuu1uuuu01000=110n000111101=0101 ================================ 19 ================================ 000u0n1000101=0un01=1100=u11n000 ================================ 20 ================================ 011100un0u001unnnn11000000001111 ================================ 21 ================================ =110=111=0===000=1=======1==1=== ================================ 22 ================================ =nuu==0110===00101=0110=====110= ================================ 23 ================================ =000============================ ================================ 24 ================================ =111============================ =======n=n=======n============== 25 ================================ ================================ ================================ 26 ================================ ================================ ===u============================ 27 ================================ ================================ ================================ 28 ================================ ================================ ================================ 29 ================================ ================================ ================================ 30 ================================ ================================ ================================ 31 ================================ ================================ ================================ 32 ================================ ================================ ================================ 33 ================================ ================================ ================================ 34 ================================ ================================ ================================ 35 ================================ ================================ ================================ 36 ================================ ================================ ================================ 37 ================================ ================================ ================================ 38 ================================ ================================ ================================ Table
5. The SFS colliding message pair for 39 steps of SHA-256 cv 02b19d5a 88e1df04 5ea3c7b7 f2f7d1a4 86cb1b1f c8ee51a5 1b4d0541 651b92e7 M c61d6de7 755336e8 5e61d618 18036de6 a79f2f1d f2b44c7b 4c0ef36b a85d45cf f72b8c2f 0def947c a0eab159 8021370c 4b0d8011 7aad07f6 33cd6902 3bad5d64 M ′ c61d6de7 755336e8 5e61d618 18036de6 a79f2f1d f2b44c7b 4c0ef36b a85d45cf e72b8c2f 0fcf907c b0eab159 81a1bfc1 4b098611 7aad07f6 33cd6902 3bad5d64 hash 431cadcd ce6893bb d6c9689a 334854e8 3baae1ab 038a195a ccf54a19 1c40606d 17 Step 2: Compute 296−ℓarbitrary first message blocks and get 296−ℓchaining inputs (A−4, . . . , A−1) and (E−4, . . . , E−1). Check TAB1 and find a match in (A−3, A−2, A−1). Then, (Wi)0≤i≤4 and E0 are all determined for this match. Step 3: At this step, (Wi)0≤i≤12 have been fixed. Use the degrees of freedom in (W13, W14, W15) to fulfill the remaining uncontrolled conditions on (E13, E14, E15, W16, W18). If it fails, go to Step 2. Supposing Step 3 succeeds with probability 2−γ, the time complexity for this two-block method to find a collision is 296−ℓ+γ + 2ℓ· Ttool, where Ttool denotes the time to find a solution of (Ai)−3≤i≤12, (Ei)1≤i≤12 and (Wi)5≤i≤12 at Step
1. The memory complexity is 2ℓ. In [27], ℓ≈34, γ ≈3.5 and Ttool is negligible. Hence the time complexity is estimated as 265.5 and the memory complexity is 234. According to the above analysis, it is clear that ℓand γ should be improved to get better attacks. Moreover, the best time-memory trade-off cannot be achieved with their 31-step differential characteristic [27]. Note that the maximal value of ℓis dominated by the number of differential conditions on steps 5−12 and hence we can expect a relatively larger ℓwith a sparser differential character- istic. Therefore, we are interested whether it is possible to find a new sparser differential characteristic with our tool that can help achieve the optimal time- memory trade-off, i.e., with time and memory complexity close to 296/2 = 248. The overall searching procedure is stated as follows:
1. Minimize the Hamming weight of ∆Wi. Specifically, find the mini- mal value of tw = P30 i=0 H(∆Wi) while keeping the minimal H(∆W16) and the minimal H(∆W18) such that the nonzero differences only exist in the 7 expanded message words (W5, W6, W7, W8, W9, W16, W18). Note that the concrete message differences are not specified at this step.
2. Minimize the Hamming weight of ∆Ai. Specifically, under the condi- tions ∀i ∈[11, 30] : δAi = 0, ∀i ∈[15, 30] : δEi = 0, ∀i ∈[0, 30] and i /∈{5, . . . , 9, 16, 18} : δWi = 0, 30 X i=0 H(∆Wi) = tw, find the minimal value of tA = P30 i=0 H(∆Ai) such that there is a solution to (∆Wi, ∆Ai, ∆Ei) for 0 ≤i ≤30 to allow a 31-step attack. Still, we only aim at the minimal value tA, and do not fix (∆Wi, ∆Ai, ∆Ei) according to the solution at this step.
3. Minimize the Hamming weight of ∆Ei. In addition to the conditions at Step 2, we further add the condition 30 X i=0 H(∆Ai) = tA. 18 Under these conditions, find and output the solution minimizing P30 i=0 H(∆Ei) to allow a 31-step attack. As already mentioned in our SAT/SMT models, to further detect the contra- dictions caused by the complex relationship between (Ai, Ei, Wi), we sometimes add the value transitions at certain steps to ensure its validity. In our model for the 31-step differential characteristic, this strategy is applied to (Ai, Ei, Wi)7≤i≤10. Without this strategy, we found that the obtained differential characteristic was indeed invalid3. Our new 31-step differential characteristic is shown in Table 6. Estimating ℓand γ. We use a dedicated method to find valid solutions of (Ai)−3≤i≤12, (Ei)1≤i≤12 and (Wi)5≤i≤12 such that ℓcan be better estimated. First, use the model for the value transitions to find a solution of (Ai)1≤i≤12, (Ei)5≤i≤12 and (Wi)9≤i≤12 that satisfy the differential conditions on steps 5−12. For simplicity, this solution is called a starting point for 31-step SHA-256. Due to Ai = Ei ⊟Ai−4 ⊞Σ0(Ai−1) ⊞MAJ(Ai−1, Ai−2, Ai−3), (2) (A−3, A−2, A−1, A0) will then depend on (E1, E2, E3, E4) for this starting point. Moreover, according to Ei = Ai−4 ⊞Ei−4 ⊞Σ1(Ei−1) ⊞IF(Ei−1, Ei−2, Ei−3) ⊞Ki ⊞Wi, (3) (E1, E2, E3, E4) will depend on (W5, W6, W7, W8) for this starting point. By analyzing the conditions on (W5, W6, W7, W8) to ensure the local collision in the message expansion, we find that there are in total 214, 223, 227 and 225 possible values of W5, W6, W7 and W8, respectively. Since there are no conditions on (E1, E2) or (A−3, A−2, A−1, A0) for this differential characteristic to hold, we only need to check how many (W7, W8) are left to ensure the conditions on (E3, E4) for this starting point. Experiments suggest that there are 211 valid (W7, W8) left. Hence, based on this starting point, we can expect to generate 214+23+11 = 248 valid solutions of (Ai)−3≤i≤12, (Ei)1≤i≤12 and (Wi)5≤i≤12. For γ, since we do not have enough degrees of freedom in (W13, W14, W15), we found that γ ≈1.3 by 100 tests. If we can generate 2ℓ1 starting points, then we have 2ℓ= 2ℓ1+48. Hence, the time complexity of the new collision attack on 31-step SHA-256 is estimated as 296−48−ℓ1+1.3 + 248+ℓ1 + 2ℓ1 · Tmodel, where Tmodel ≈231.7 denotes the time to generate a starting point and is always negligible. With ℓ1 = 0, i.e., only using one starting point, the time complexity is about 249.8 and the memory complexity is 248. With this improved attack, we are much closer to a practical collision attack on 31-step SHA-256 and the bottleneck is the memory consumption. A possible practical implementation is to use less memory at the cost of increased time complexity. 3 When searching for the differential characteristic for 39-step SHA-256, this strategy was not applied because we found that the obtained differential characteristic was valid. 19 Table
[6] that they could not find better collision attacks on SHA-512 because they could not find a suitable differential characteristic with their tools. In this part, we show how to overcome this obstacle. Our practical SFS collision attack on 39-step SHA-256 benefits much from the practical SFS collision attack on 39-step SHA-512 due to their similarity. Hence, we feel interested to know whether it is possible to find a suitable differ- ential characteristic for 31-step SHA-512 based on the collision attack on 31-step SHA-256
[27] with our new tool. Specifically, similar to the 31-step attack on SHA-256, the nonzero message differences are injected in (W5, W6, W7, W8, W9, W16, W18), and the local collision in the message expansion spans over 14 steps (steps 5−28), as shown in Figure 2(b). Similar to the collision attack on 31-step SHA-256, we first find SFS collisions and then convert them into collisions with the two- block method. The general procedure to convert SFS collisions into collisions is essentially the same and we refer the readers to the above improved attack on 31-step SHA-256. The most challenging step to achieve the collision attack on 31-step SHA-512 is how to find a valid differential characteristic. In what follows, we describe how to use our tool to solve this problem. Step 1: Find a solution of (∆Wi)0≤i≤30 with the minimal P30 i=0 H(∆Wi), while keeping the minimal H(∆W16) and the minimal H(∆W18), which allows a local collision in the message expansion. Step 2: With the fixed solution of (∆Wi)0≤i≤30 obtained at Step 1, find a valid solution of (∆Ai, ∆Ei)0≤i≤30, which follows the shape of the 31-step differential characteristic shown in Figure 2(b). Here, set a threshold to P30 i=0 H(∆Ai). Specifically, choose an integer tr and add the constraint 30 X i=0 H(∆Ai) ≤tr to the model. If the solver cannot output a solution in a reasonable time, e.g., 72 hours, increase tr until a valid solution of (∆Ai, ∆Ei)0≤i≤30 is found. Keep the solution of (∆Ai)0≤i≤30. Step 3: With the fixed solution of (∆Ai, ∆Wi)0≤i≤30, find a valid solution of (∆Ei)0≤i≤30 with the minimal P30 i=0 H(∆Ei), which allows a 31-step collision attack. It is found that the obtained 31-step differential characteristic is invalid. There- fore, we propose to use the following method to correct this obtained solution. 21 Step 1: Set (∆Ei)5≤i≤7 as unknown variables. For the remaining (∆Ei)0≤i≤30 where i /∈{5, 6, 7}, keep them the same as those in the obtained solu- tion. For (∆Ai)0≤i≤30 and (∆Wi)0≤i≤30, they are also kept the same as those in the obtained solution. Step 2: Add the constraints describing the value transitions for (Ai, Ei, Wi)7≤i≤12 to the model. In summary, we utilize the degrees of freedom in (∆Ai, ∆Ei)5≤i≤7 and the model for value transitions to correct an invalid 31-step differential characteristic. In our search, the corresponding 31-step differential characteristic is shown in Table 7. Complexity evaluation. As already mentioned, the only challenge to achieve the collision attack on 31-step SHA-512 is to find a suitable differential char- acteristic. Once it is found, the two-block method for 31-step SHA-256 can be directly applied. For consistency, we use the same notation, i.e., use (ℓ, γ, ℓ1) to describe the time complexity and memory complexity as in the above collision attack on 31-step SHA-256. For our 31-step differential characteristic, there are in total 236, 226, 225 and 243 possible values for W5, W6, W7 and W8, respec- tively. For each starting point, i.e., the solution of (Ai)1≤i≤12, (Ei)5≤i≤12 and (Wi)9≤i≤12, we have experimentally found that there are on average 215.3 pos- sible (W7, W8) that can make the conditions on (E3, E4) hold. Therefore, for each starting point, we can generate 236+26+15.3 = 277.3 candidate solutions of (Ai)−3≤i≤12, (Ei)1≤i≤12 and (Wi)5≤i≤12. For 2ℓ1 starting points, we thus can expect to generate 2ℓ= 2ℓ1+77.3 such many solutions. For γ, similarly, we found γ ≈0.9 according to 100 experiments. Since the time complexity to generate a starting point is negligible, the whole time complexity is estimated as 264×3−(ℓ1+77.3)+0.9 + 2ℓ1+77.3 and the memory complexity is 2ℓ1+77.3. With ℓ1 = 0, i.e., only one starting point, the time and memory complexity are 2115.6 and 277.3, respectively. 4.4 The Practical Collision Attack on 28-Step SHA-512 Similar to the 28-step attack on SHA-256 [27], the nonzero message differences are injected in (W8, W9, W13, W16, W18), and the local collision in the message expansion spans over 11 steps (steps 8−18), resulting in a collision on 28-step SHA-512. The most challenging step to achieve the collision attack on 28-step SHA-512 is how to find a valid differential characteristic. In what follows, we describe how to use our tool to solve this problem. Step 1: Find a solution of (∆Wi)0≤i≤27 with the minimal P27 i=0 H(∆Wi) while keeping the minimal H(∆W16) and the minimal H(∆W18), which allows a local collision in the message expansion. 22 Table
7. The differential characteristic for 31-step SHA-512 i ∆Ai ∆Ei ∆Wi -4 ================================================================ ================================================================ -3 ================================================================ ================================================================ -2 ================================================================ ================================================================ -1 ================================================================ ================================================================ 0 ================================================================ ================================================================ ================================================================ 1 ================================================================ ================================================================ ================================================================ 2 ================================================================ ================================================================ ================================================================ 3 ================================================================ =11=00000====10=0=====000==101=0===1========0===1==1==011110==== ================================================================ 4 ================================================================ =00011100=11101=1===10111==010=1===0===1=10=01=00==101101011=10= ================================================================ 5 =nunuuuuuu======u======u===unnnu===u=n======u=====nn===unnnn==== uuu1nuuuuu101unnn10001ununnnnn1n=1unnu10=010u011nu0u11unnnnn1111 ==n======n=====un======u=====u=nunnnnu======u=====nn=======u==== 6 ========n=======u=================un=======u=====unnnn====nuunn= 00nnnnnnu0unu0u0n111unnn101u010u0011110u0un0nn0uu11uun10n0nn1nu1 n0u011=01u=====0n====10n====un=============n====uu===u=u=nuuuuu= 7 =n======nunnu==u=u=========u==uu=n=u========nnn====n=====u=u==== u1uu11u1n0nuu1000nnu10uu1un1uu0u110un111110nu1uu0n1010011nn=uu1u =u=============n============u====u==unn==n====u=======n=0=1====u 8 ===============================================================u 11110011001100u000100u1n00n0011==n=0000n=0nu0un0n1n00010n0111110 n=====nu=====u=====nu=====n======u=====u======u==========0====== 9 ========================n======================================= 11n1==111=010111011101unn01000u0=011u1u00=0110010101=1==10101101 ============u============n============n========================n 10 ============u===========nu============n======================nuu ==10==1===111=10u0==101=0n0==11==11010n11=1u=0110=0=0n==1101=nuu ================================================================ 11 ================================================================ =1u1======un0=n=nn===11001u==un====unnn0n==n=========u==u=10=100 ================================================================ 12 ================================================================ =000======00n=1=11===10==u1==00===1010u11==1=========1==1==0=11u ================================================================ 13 ================================================================ ==1=======110=1=01=======11==11====1111=1==0=========0==1======1 ================================================================ 14 ================================================================ ============u============n============n========================n ================================================================ 15 ================================================================ ============0============0============0========================0 ================================================================ 16 ================================================================ ============1============1============1========================1 =======unnnnn====nuuuuuuuu=======nuuuuu==========11====nuuuuuuuu 17 ================================================================ ================================================================ ================================================================ 18 ================================================================ ================================================================ ============n============u============u========================u 19 ================================================================ ================================================================ ================================================================ 20 ================================================================ ================================================================ ================================================================ 21 ================================================================ ================================================================ ================================================================ 22 ================================================================ ================================================================ ================================================================ 23 ================================================================ ================================================================ ================================================================ 24 ================================================================ ================================================================ ================================================================ 25 ================================================================ ================================================================ ================================================================ 26 ================================================================ ================================================================ ================================================================ 27 ================================================================ ================================================================ ================================================================ 28 ================================================================ ================================================================ ================================================================ 29 ================================================================ ================================================================ ================================================================ 30 ================================================================ ================================================================ ================================================================ 23 Step 2: Find the suitable ∆Ei. With the fixed solution of (∆Wi)0≤i≤27 ob- tained at Step 1, find a valid solution of (∆Ai, ∆Ei)0≤i≤27. To improve the efficiency of the message modification, we have tried three strategies for Step 2, as detailed below: Strategy 1: First, with the fixed solution of (∆Wi)0≤i≤27, find a valid solution of (∆Ai, ∆Ei)0≤i≤27, and we minimize P27 i=0 H(∆Ai). Then, with the fixed solution of (∆Wi, ∆Ai)0≤i≤27, find a valid so- lution of (∆Ei)0≤i≤27 with the minimal P27 i=0 H(∆Ei). Strategy 2: With the fixed solution of (∆Wi)0≤i≤27, find a valid solution of (∆Ai, ∆Ei)0≤i≤27, and we minimize P27 i=0 H(∆Ei). Strategy 3: With the fixed solution of (∆Wi)0≤i≤27, find a valid solution of (∆Ai, ∆Ei)0≤i≤27, and we minimize P27 i=11 H(∆Ei). After testing, it is found that Strategy 3 is more suitable for message mod- ifications. However, such a 28-step differential characteristic is invalid. Similar to the method to correct the SHA-512 31-step differential characteristic, we also use the same technique to correct this invalid 28-step differential characteristic. Step 1: Set (∆Ei)8≤i≤10 as unknown variables. For the remaining (∆Ei)0≤i≤27 where i /∈{8, 9, 10}, keep them the same as those in the obtained so- lution. For (∆Ai)0≤i≤27 and (∆Wi)0≤i≤27, they are also kept the same as those in the obtained solution. Step 2: Add the constraints describing the value transitions for (Ai, Ei, Wi)10≤i≤12 to the model. With this method, we eventually found a valid 28-step differential characteristic, as shown in Table 8. Message modification. We use a different message modification technique than in [27]. In our message modification technique, we first determine all ex- panded message words and state variables in steps 8−12. Since the first 8 message words can be (almost) freely chosen, it is easy to connect the (Ai, Ei)−4≤i≤−1 and (Ai, Ei)8≤i≤12 by using (Wi)0≤i≤7. Currently, (Ai, Ei)−4≤i≤12 and (Wi)0≤i≤12 has been determined. Then, the degree of freedom in message words W13 −W15 can be used to fulfill the conditions on E13 −E15 and (W16, W18). With this method, the cost to find the colliding message pair is almost negligible. The colliding message pair is shown in Table 9. 4.5 The First Practical FS Collision for 40-step SHA-224 In SHA-224, the last one output word (E60 + E−4) was truncated. Therefore, similar to [6], we inject differences in E−4 to mount a FS collision attack. The best practical FS collision attack on SHA-224 was presented in
[6] and it reaches 24 Table
8. The differential characteristic for 28-step SHA-512 i ∆Ai ∆Ei ∆Wi -4 ================================================================ ================================================================ -3 ================================================================ ================================================================ -2 ================================================================ ================================================================ -1 ================================================================ ================================================================ 0 ================================================================ ================================================================ ================================================================ 1 ================================================================ ================================================================ ================================================================ 2 ================================================================ ================================================================ ================================================================ 3 ================================================================ ================================================================ ================================================================ 4 ================================================================ ================================================================ ================================================================ 5 ================================================================ ================================================================ ================================================================ 6 ================================================================ =100=10=1011101=100010011=1000101=0==0=011==110==1001100=======0 ================================================================ 7 ================================================================ =001=11000100110010001010=111101001==1010111011000110000=0=0==01 ================================================================ 8 ====unnnuuuuu=n======n=nn=u=u=nuuunuu==u=u==nuu=nuu=u=n=u=====un =unnnnn0nuuuunu1nuuuuununununnuuu0uuuunnun00nuu10nuunnuun101110u ======u=nuuuunu====nu=uunu=nn===nu=nuun=nn===nu==nu=u=n=u======u 9 ====unnnn==nnnuuuuuuuuuuuuuuuuuuuuuu=====n====nuuu=nnuu======n== 1un01unn1nnunnuun0nuuuunu0unuu111un110unununnnnnn0nn10nn1u1u01nn 1000001unnnnn0110011=nuuuu========nuuuu===========nuuuuuuuuuuuuu 10 ======unnnnnn===========nu=======nuuuuunuuuuuuuuuuuuuuuuuuuuuuuu =01000=10111u1=0111=0=101n101100010000111=01=111101101010010=nuu ================================================================ 11 ================================================================ ==u0100unnn00n1n0n11010101u000u=000=1011n10u010000010u0un0111101 ================================================================ 12 ================================================================ =100===0111n10=1=1===11==u1==10=======u=1=01====1===01=10====00u ================================================================ 13 ================================================================ ==1====11110n1=101=======10===0=======0=1==1=====1===0=11======1 =========n============u============n=====================u==n=== 14 ================================================================ ===========0u============n========0===n========================n ================================================================ 15 ================================================================ ============1============0============0========================0 ================================================================ 16 ================================================================ ============0============1============1========================1 =======unnnnn====nuuuuuuuu=======nuuuuu==========11====nuuuuuuuu 17 ================================================================ ================================================================ ================================================================ 18 ================================================================ ================================================================ ============n============u============u========================u 19 ================================================================ ================================================================ ================================================================ 20 ================================================================ ================================================================ ================================================================ 21 ================================================================ ================================================================ ================================================================ 22 ================================================================ ================================================================ ================================================================ 23 ================================================================ ================================================================ ================================================================ 24 ================================================================ ================================================================ ================================================================ 25 ================================================================ ================================================================ ================================================================ 26 ================================================================ ================================================================ ================================================================ 27 ================================================================ ================================================================ ================================================================ 25 Table
10. The differential characteristic for 40 steps of SHA-224 i ∆Ai ∆Ei ∆Wi -4 ================================ ===u============================ -3 ================================ ================================ -2 ================================ ================================ -1 ================================ ================================ 0 ================================ ================================ ===n============================ 1 ================================ ================================ ================================ 2 ================================ ================================ ================================ 3 ================================ ================================ ================================ 4 ================================ ================================ ================================ 5 ================================ ================================ ================================ 6 ================================ ================================ ================================ 7 ================================ 0111============================ ================================ 8 ================================ 1000=========10======1===1==1=== ================================ 9 ===u============================ unnn1=0=00=0=00=01=1=100=0110=1= ===u============================ 10 ==============n=u====u======n=== 100n0n110111=nu00011un101n11n=00 ======n===u==========u========== 11 ================================ 0101u0n=1n0n010=u0=10nun=1u01=n1 ===n============================ 12 ================================ =10001000010001=0===0110=10=1=0= =======nn=======n===n===nn==uu=u 13 ================================ =unn00000001100011=00011==0=101= =============u=======nn========= 14 ================================ 11100nuuuuuuuuu1u=01un000001n001 ================================ 15 ================================ =111=0000000000=0=1=001111111=1= ================================ 16 ============================n=== 11001101101000000101nuuuuuuuu001 ================================ 17 =======u=u=======u============== 010100unu000001001u1000110unn=n1 ======n===u==========u========== 18 ================================ 1100111u00nn=100110=u1u00unn000n ===n============================ 19 ===n============================ uuu1uuuu01000=110n000111101=0101 ================================ 20 ================================ 000u0n1000101=0un01=1100=u11n000 ================================ 21 ================================ 011100un1u001unnnn11000000101111 ================================ 22 ================================ =110=111=0===11101=======1==1=== ================================ 23 ================================ =nuu==0110===00101=0110=====110= ================================ 24 ================================ =000============================ ================================ 25 ================================ =111============================ =======n=n=======n============== 26 ================================ ================================ ================================ 27 ================================ ================================ ===u============================ 28 ================================ ================================ ================================ 29 ================================ ================================ ================================ 30 ================================ ================================ ================================ 31 ================================ ================================ ================================ 32 ================================ ================================ ================================ 33 ================================ ================================ ================================ 34 ================================ ================================ ================================ 35 ================================ ================================ ================================ 36 ================================ ================================ ================================ 37 ================================ ================================ ================================ 38 ================================ ================================ ================================ 39 ================================ ================================ ================================ Table
11. The FS colliding message pair for 40 steps of SHA-224 CV 791c9c6b baa7f900 f7c53298 9073cbbd c90690c5 5591553c 43a5d984 af92402d CV ′ 791c9c6b baa7f900 f7c53298 9073cbbd c90690c5 5591553c 43a5d984 bf92402d M f41d61b4 ce033ba2 dd1bc208 a268189b ee6bda2c 5ddbe94d 9675bbd3 32c1ba8a 7eba797d 88b06a8f 3bc3015c d36f38cc cfcb88e0 3c70f7f3 faa0c1fe 35c62535 M ′ e41d61b4 ce033ba2 dd1bc208 a268189b ee6bda2c 5ddbe94d 9675bbd3 32c1ba8a 7eba797d 98b06a8f 39e3055c c36f38cc ce4b002d 3c74f1f3 faa0c1fe 35c62535 hash 9af50cac c165a72f b6f1c9f3 ef54bad9 af0cfb1f 57d357c9 c6462616 27 Key Research and Development Program of China (No. 2022YFB2701900), the National Natural Science Foundation of China (No. 62072181). Fukang Liu is supported by Grant-in-Aid for Research Activity Start-up (Grant No. 22K21282). References
7. Draft, F.: Public comments on the draft federal information processing standard (fips) draft fips 180-2, secure hash standard (shs)
10. Indesteege, S., Mendel, F., Preneel, B., Rechberger, C.: Collisions and other non- random properties for step-reduced SHA-256. In: SAC. Lecture Notes in Computer Science, vol. 5381,  Springer (2008). https://doi.org/10.1007/978-3-64 2-04159-4_18
24. Mendel, F., Nad, T., Scherz, S., Schläffer, M.: Differential attacks on reduced RIPEMD-160. In: ISC. Lecture Notes in Computer Science, vol. 7483, Springer (2012). https://doi.org/10.1007/978-3-642-33383-5_2
31. Mironov, I., Zhang, L.: Applications of SAT solvers to cryptanalysis of hash func- tions. In: SAT. Lecture Notes in Computer Science, vol. 4121,  Springer (2006), https://doi.org/10.1007/11814948_13
33. Sanadhya, S.K., Sarkar, P.: New collision attacks against up to 24-step SHA-2. In: INDOCRYPT. Lecture Notes in Computer Science, vol. 5365,  Springer (2008). https://doi.org/10.1007/978-3-540-89754-5_8
41. Yu, H., Bai, D.: Boomerang attack on step-reduced SHA-512. In: Inscrypt. Lecture Notes in Computer Science, vol. 8957,  Springer (2014). https://doi. org/10.1007/978-3-319-16745-9_18
8. Howgrave-Graham, N.A.: Computational Mathematics Inspired by RSA. Ph.D. thesis, University of Bath (1998). https://researchportal.bath.ac.uk/en/ studentTheses/computational-mathematics-inspired-by-rsa
13. May, A.: Using LLL-reduction for solving RSA and factorization problems. In: Nguyen, P., Vall´ee, B. (eds.) The LLL Algorithm. Information Security and Cryp- tography. Springer, Heidelberg (2009). https://doi.org/10.1007/978-3-642-02295- 1 10 218 M. R. Albrecht et al.
14. MEGA: About Us, September 2022. https://mega.io/about
15. MEGA: Mega.nz web client (2022). https://github.com/meganz/webclient
17. MEGA: webclient - #15273: Patch for ETH Zurich exploit, June 2022. https://github.com/meganz/webclient/commit/d2a0d054d4dbb90f035b3b4b421f 780adafaa78e
18. MEGA: webclient - #15295: Output detailed information about RSA decoding failures, June 2022. https://github.com/meganz/webclient/commit/ cd4ab89b2cd0e388b0ea55753b86c8808f810138
27. MEGA: webclient - security.js: decryptRsaKeyAndSessionId, August 2022. https://github.com/meganz/webclient/blob/v4.21.4/js/security.js#L1231
32. The FPLLL development team: FPLLL, a lattice reduction library (2021). https:// github.com/fplll/fplll
33. The mitmproxy development team: mitmproxy - an interactive HTTPS proxy (2022). https://mitmproxy.org/
36. Wikipedia: UTF-8 (2022). https://en.wikipedia.org/wiki/UTF-8
[BCG+18] Bitansky, N., et al.: Indistinguishability obfuscation for ram programs and succinct randomized encodings. SIAM J. Comput. 47(3), 1123–1210 (2018)
[CHJV15] Canetti, R., Holmgren, J., Jain, A., Vaikuntanathan, V.: Succinct gar- bling and indistinguishability obfuscation for RAM programs. In: Serve- dio, R.A., Rubinfeld, R. (eds.) 47th Annual ACM Symposium on Theory of Computing,  ACM Press, June 2015
[GHRW14] Gentry, C., Halevi, S., Raykova, M., Wichs, D.: Outsourcing private RAM computation. In: 55th Annual Symposium on Foundations of Computer Science,  IEEE Computer Society Press, October 2014
[GKP+13] Goldwasser, S., Kalai, Y.T., Popa, R.A., Vaikuntanathan, V., Zeldovich, N.: Reusable garbled circuits and succinct functional encryption. In: Boneh, D., Roughgarden, T., Feigenbaum, J. (eds.) 45th Annual ACM Symposium on Theory of Computing,  ACM Press, June 2013
[GO96] Goldreich, O., Ostrovsky, R.: Software protection and simulation on obliv- ious rams. J. ACM 43(3), 431–473 (1996)
[Gra10] Grauman, K.: Eﬃciently searching for similar images. Commun. ACM 53(6), 84–94 (2010) 218 F. Dong et al.
[JLS21] Jain, A., Lin, H., Sahai, A.: Indistinguishability obfuscation from well- founded assumptions. In: Khuller, S., Williams, V.V. (eds.) 53rd Annual ACM Symposium on Theory of Computing,  ACM Press, June 2021
[LMW22] Lin, W.-K., Mook, E., Wichs, D.: Doubly eﬃcient private information retrieval and fully homomorphic ram computation from ring LWE. Cryp- tology ePrint Archive, Paper 2022/1703 (2022). https://eprint.iacr.org/ 2022/1703
[QWW18] Quach, W., Wee, H., Wichs, D.: Laconic function evaluation and appli- cations. In: Thorup, M. (ed.) 59th Annual Symposium on Foundations of Computer Science,  IEEE Computer Society Press, October 2018
1. Aggarwal, D., Dadush, D., Regev, O., Stephens-Davidowitz, N.: Solving the short- est vector problem in 2n time using discrete Gaussian sampling. In: Proceedings of the Forty-Seventh Annual ACM Symposium on Theory of Computing, (2015)
4. Becker, A., Ducas, L., Gama, N., Laarhoven, T.: New directions in nearest neigh- bor searching with applications to lattice sieving. In: Proceedings of the Twenty- Seventh Annual ACM-SIAM Symposium on Discrete Algorithms,  SIAM (2016)
7. Brakerski, Z., Langlois, A., Peikert, C., Regev, O., Stehl´e, D.: Classical hardness of learning with errors. In: STOC,  (2013)
9. Conway, J.H., Sloane, N.J.A.: Sphere Packings, Lattices and Groups, vol. 290. Springer, Heidelberg (2013)
10. Damg˚ard, I.: On -protocols. Lecture Notes, University of Aarhus, Department for Computer Science (2002)
11. Ducas, L., Pierrot, C.: Polynomial time bounded distance decoding near Minkowski’s bound in discrete logarithm lattices. Des. Codes Crypt. 87(8), 1737– 1748 (2019). https://doi.org/10.1007/s10623-018-0573-3
14. Goldreich, O., Micali, S., Wigderson, A.: Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. J. ACM (JACM) 38(3), 690–728 (1991)
15. H˚astad, J., Impagliazzo, R., Levin, L.A., Luby, M.: A pseudorandom generator from any one-way function. SIAM J. Comput. 28(4), 1364–1396 (1999)
16. Haviv, I., Regev, O.: Hardness of the covering radius problem on lattices. In: IEEE Conference on Computational Complexity,  (2006)
17. Haviv, I., Regev, O.: On the lattice isomorphism problem. In: Proceedings of the Twenty-Fifth Annual ACM-SIAM Symposium on Discrete Algorithms,  SIAM (2014)
19. Klein, P.N.: Finding the closest lattice vector when it’s unusually close. In: SODA, (2000)
21. Lenstra, A.K., Lenstra, H.W., Jr., Lov´asz, L.: Factoring polynomials with rational coeﬃcients. Math. Ann. 261(4), 515–534 (1982)
26. Merkle, R., Hellman, M.: Hiding information and signatures in trapdoor knapsacks. IEEE Trans. Inf. Theory 24(5), 525–530 (1978)
31. Mook, E., Peikert, C.: Lattice (list) decoding near Minkowski’s inequality. IEEE Trans. Inf. Theory 68(2), 863–870 (2022)
36. Peikert, C., Waters, B.: Lossy trapdoor functions and their applications. SIAM J. Comput. 40(6), 1803–1844 (2011)
37. Plesken, W., Pohst, M.: Constructing integral lattices with prescribed minimum. I. Math. Comput. 45(171), 209–221 (1985)
40. Schnorr, C.P.: A hierarchy of polynomial time lattice basis reduction algorithms. Theor. Comput. Sci. 53, 201–224 (1987)
41. Sendrier, N.: Finding the permutation between equivalent linear codes: the support splitting algorithm. IEEE Trans. Inf. Theory 46(4), 1193–1203 (2000)
42. Serre, J.P.: A Course in Arithmetic, vol.
7. Springer, Heidelberg (2012)
44. Sikiric, M.D., Haensch, A., Voight, J., van Woerden, W.P.: A canonical form for positive deﬁnite matrices. In: ANTS XIV, p. 179 (2020)
1. Aaronson, S.: Quantum copy-protection and quantum money. In: 2009 24th Annual IEEE Conference on Computational Complexity,  IEEE (2009). https://doi.org/10.1109/ccc.2009.42
2. Aaronson, S., Christiano, P.: Quantum money from hidden subspaces. In: Karloﬀ, H.J., Pitassi, T. (eds.) 44th ACM STOC,  ACM Press (2012). https:// doi.org/10.1145/2213977.2213983
5. Amos, R., Georgiou, M., Kiayias, A., Zhandry, M.: One-shot signatures and applications to hybrid quantum/classical authentication. In: Makarychev, K., Makarychev, Y., Tulsiani, M., Kamath, G., Chuzhoy, J. (eds.) 52nd ACM STOC, ACM Press (2020). https://doi.org/10.1145/3357713.3384304
18. Coladangelo, A., Majenz, C., Poremba, A.: Quantum copy-protection of compute- and-compare programs in the quantum random oracle model. arXiv:2009.13865 (2020)
19. Culf, E., Vidick, T.: A monogamy-of-entanglement game for subspace coset states. Quantum 6, 791 (2022). https://doi.org/10.22331/q-2022-09-01-791
27. Kitagawa, F., Nishimaki, R.: Functional encryption with secure key leasing. Asi- acrypt 2022 (to appear) (2022)
30. Marriott, C., Watrous, J.: Quantum arthur-merlin games. Comput. Complex. 14(2), 122–152 (2005). https://doi.org/10.1007/s00037-005-0194-x
31. Poremba, A.: Quantum proofs of deletion for learning with errors. In: Kalai, Y.T. (ed.) 14th Innovations in Theoretical Computer Science Conference, ITCS 2023, January 10–13, 2023, MIT, Cambridge, Massachusetts, USA. LIPIcs, vol. 251, pp. 90:1–90:14. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik (2023). https://doi. org/10.4230/LIPIcs.ITCS.2023.90
34. Unruh, D.: Revocable quantum timed-release encryption. J. ACM 62(6), 49:1– 49:76 (2015)
35. Wiesner, S.: Conjugate coding. ACM Sigact News 15(1), 78–88 (1983). https:// doi.org/10.1145/1008908.1008920
36. Winter, A.J.: Coding theorem and strong converse for quantum channels. IEEE Trans. Inf. Theory 45(7), 2481–2485 (1999). https://doi.org/10.1109/18.796385
12. Mahmoody, M., Moran, T., Vadhan, S.P.: Publicly veriﬁable proofs of sequential work. In: Kleinberg, R.D. (ed.) ITCS 2013.  ACM (Jan 2013). https: //doi.org/10.1145/2422436.2422479
13. Pietrzak, K.: Simple veriﬁable delay functions. In: Blum, A. (ed.) ITCS 2019. vol. 124, pp. 60:1–60:15. LIPIcs (Jan 2019). https://doi.org/10.4230/LIPIcs. ITCS.2019.60
4. Armknecht, F., Katzenbeisser, S., Peter, A.: Group homomorphic encryption: char- acterizations, impossibility results, and applications. Des. Codes Crypt. 67, 209– 232 (2013)
10. Biasse, J.F., Fieker, C.: Subexponential class group and unit group computation in large degree number ﬁelds. LMS J. Comput. Math. 17(A), 385–403 (2014)
11. Biasse, J.F., Song, F.: Eﬃcient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number ﬁelds. In: SODA16, SIAM (2016)
12. Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resis- tance to succinct non-interactive arguments of knowledge, and back again. In: ITCS 2012,  (2012)
14. Boneh, D., Segev, G., Waters, B.: Targeted malleability: homomorphic encryption for restricted computations. In: ITCS 2012,  (2012)
17. Brakerski, Z., Gentry, C., Vaikuntanathan, V.: (leveled) fully homomorphic encryp- tion without bootstrapping. In: ITCS 2012,  (2012)
23. Chen, H., Laine, K., Rindal, P.: Fast private set intersection from homomorphic encryption. In: ACM SIGSAC 2017,  (2017)
38. Geva, R., et al.: Collaborative privacy-preserving analysis of oncological data using multiparty homomorphic encryption. Proc. Natl. Acad. Sci. 120(33), e2304415120 (2023)
44. Lu, W.J., Huang, Z., Hong, C., Ma, Y., Qu, H.: Pegasus: bridging polynomial and non-polynomial evaluations in homomorphic encryption. In: S&P 2021,  IEEE (2021)
51. Rivest, R.L., Adleman, L., Dertouzos, M.L., et al.: On data banks and privacy homomorphisms. Found. Secure Comput. 4(11), 169–180 (1978)
52. Sahai, A.: Non-malleable non-interactive zero knowledge and adaptive chosen- ciphertext security. In: FOCS 1999,  IEEE (1999)
53. Viand, A.: Useable Fully Homomorphic Encryption. Ph.D. thesis, ETH Zurich (2023)
54. Viand, A., Knabenhans, C., Hithnawi, A.: Veriﬁable fully homomorphic encryption. arXiv preprint arXiv:2301.07041 (2023)
55. Wang, B., Wang, X., Xue, R.: CCA1 secure FHE from PIO, revisited. Cybersecu- rity 1(1), 1–8 (2018)
57. Zhang, Z., Plantard, T., Susilo, W.: Reaction attack on outsourced computing with fully homomorphic encryption schemes. In: Kim, H. (eds.) ICISC 2011.  Springer, Heidelberg (2012). https://doi.org/10.1007/978-3-642-31912-9 28
1. Ajtai, M.: Secure computation with information leaking to an adversary,  (2011)
6. Bela¨ıd, S., Mercadier, D., Rivain, M., Taleb, A.R.: IronMask: versatile veriﬁcation of masking security,  (2022)
11. Cassiers, G., Standaert, F.-X.: Towards globally optimized masking: from low ran- domness to low noise rate 2019(2), 162–198 (2019). https://tches.iacr.org/index. php/TCHES/article/view/7389
14. Coron, J.-S., Rondepierre, F., Zeitoun, R.: High order masking of look-up tables with common shares 2018(1):40–72 (2018). https://tches.iacr.org/index.php/ TCHES/article/view/832
21. Kocher, P.C., Jaﬀe, J., Jun, B.: Diﬀerential power analysis,  (1999)
6. Demmler, D., Rindal, P., Rosulek, M., Trieu, N.: Pir-psi: scaling private contact discovery. Proc. Priv. Enhanc. Technol. 159–178(10) (2018)
10. Goldreich, O., Goldwasser, S., Micali, S.: How to construct random functions. J. ACM 33(4), 792–807 (1986)
[Ajt96] Ajtai, M.: Generating hard instances of lattice problems (extended abstract). In: STOC,  (1996)
[BDK+18] Bos, J.W., et al.: CRYSTALS - kyber: A cca-secure module-lattice-based KEM. In: EuroS&P,  IEEE (2018)
[BS16] Biasse, J.F., Song, F.: Eﬃcient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number ﬁelds. In: Proceedings of the Twenty-Seventh Annual ACM-SIAM Sympo- sium on Discrete Algorithms,  SIAM (2016)
[BV11] Brakerski, Z., Vaikuntanathan, V.: Eﬃcient fully homomorphic encryption from (standard) LWE. In: IEEE 52nd Annual Symposium on Foundations of Computer Science, FOCS 2011, Palm Springs, CA, USA, 22–25 October 2011,  (2011)
[CGS14] Campbell, P., Groves, M., Shepherd, D.: Soliloquy: A cautionary tale (2014)
[CN97] Cai, J.Y., Nerurkar, A.: An improved worst-case to average-case connection for lattice problems. In: FOCS,  IEEE Computer Society (1997)
[CvD07] Childs, A.M., Dam, W.V.: Quantum algorithm for a generalized hidden shift problem. In: SODA,  SIAM (2007)
[EHKS14] Eisentr¨ager, K., Hallgren, S., Kitaev, A.Y., Song, F.: A quantum algorithm for computing the unit group of an arbitrary degree number ﬁeld. In: STOC, ACM (2014)
[ES16] Eldar, L., Shor, P.W.: An eﬃcient quantum algorithm for a variant of the closest lattice-vector problem (2016)
[FIM+03] Friedl, K., Ivanyos, G., Magniez, F., Santha, M., Sen, P.: Hidden translation and orbit coset in quantum computing. In: STOC,  ACM (2003)
[GGH96] Goldreich, O., Goldwasser, S., Halevi, S.: Collision-free hashing from lattice problems. Electron. Colloq. Comput. Compl. (ECCC) 3(42) (1996)
[GKZ19] Grilo, A.B., Kerenidis, I., Zijlstra, T.: Learning-with-errors problem is easy with quantum samples. Phys. Rev. A 99(3), 032314 (2019)
[GVW13] Gorbunov, S., Vaikuntanathan, V., Wee, H.: Attribute-based encryption for circuits. In: STOC,  ACM (2013)
[IPS18] Ivanyos, G., Prakash, A., Santha, M.: On learning linear functions from sub- set and its applications in quantum computing. In: ESA, vol. 112 of LIPIcs, pp. 66:1–66:14. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik (2018)
[Kup05] Kuperberg, G.: A subexponential-time quantum algorithm for the dihedral hidden subgroup problem. SIAM J. Comput. 35(1), 170–188 (2005)
[Mah18] Mahadev, U.: Classical homomorphic encryption for quantum circuits. In: FOCS,  IEEE Computer Society (2018)
[MS19] Miller, S.D., Stephens-Davidowitz, N.: Kissing numbers and transference theorems from generalized tail bounds. SIAM J. Disc. Math. 33(3), 1313– 1325 (2019)
[NC16] Nielsen, M.A., Chuang, I.L.: Quantum Computation and Quantum Infor- mation (10th Anniversary edition). Cambridge University Press, Cambridge (2016)
[Per88] Peres, A.: How to diﬀerentiate between non-orthogonal states. Phys. Lett. A 128, 19–19 (1988)
[Reg02] Regev, O.: Quantum computation and lattice problems. In: FOCS,  IEEE Computer Society (2002)
[Reg05] Regev, O.: On lattices, learning with errors, random linear codes, and cryp- tography. In: STOC,  ACM (2005)
[SE94] Schnorr, C.-P., Euchner, M.: Lattice basis reduction: improved practical algorithms and solving subset sum problems. Math. Program. 66(1), 181– 199 (1994)
[ABG+11] Ron Aharoni, Eli Berger, Agelos Georgakopoulos, Amitai Perlstein, and Philipp Sprüs- sel. The max-flow min-cut theorem for countable networks. Journal of Combinatorial Theory, Series B, 101(1):1–17, 2011.
[EFM+19] Úlfar Erlingsson, Vitaly Feldman, Ilya Mironov, Ananth Raghunathan, Kunal Talwar, and Abhradeep Thakurta. Amplification by shuffling: From local to central differential privacy via anonymity. In Timothy M. Chan, editor, 30th SODA, pages 2468–2479. ACM-SIAM, January 2019. [EZ19] Saba Eskandarian and Matei Zaharia. Oblidb: Oblivious query processing for secure databases. Proc. VLDB Endow., 13(2):169–183, 2019. [FHLS19] Alireza Farhadi, MohammadTaghi Hajiaghayi, Kasper Green Larsen, and Elaine Shi. Lower bounds for external memory integer sorting via network coding. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 997–1008. ACM Press, June 2019. [FMT22] Vitaly Feldman, Audra McMillan, and Kunal Talwar. Hiding among the clones: A simple and nearly optimal analysis of privacy amplification by shuffling. In 62nd FOCS, pages 954–964. IEEE Computer Society Press, February 2022.
[GDD+21] Antonious M. Girgis, Deepesh Data, Suhas Diggavi, Peter Kairouz, and Ananda Theertha Suresh. Shuffled model of federated learning: Privacy, accuracy and communication trade-offs. IEEE Journal on Selected Areas in Information Theory, 2(1):464–478, 2021.
[GIKM00] Yael Gertner, Yuval Ishai, Eyal Kushilevitz, and Tal Malkin. Protecting data privacy in private information retrieval schemes. JCSS, 2000.
[GKMP21] Badih Ghazi, Ravi Kumar, Pasin Manurangsi, and Rasmus Pagh. Private counting from anonymous messages: Near-optimal accuracy with vanishing communication overhead, 2021.
1. Abboud, A., Rubinstein, A., Williams, R.R.: Distributed PCP theorems for hard- ness of approximation in P. In: Umans, C. (ed.) 58th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2017, Berkeley, 15–17 October 2017,  IEEE Computer Society (2017)
2. Arora, S., Lund, C., Motwani, R., Sudan, M., Szegedy, M.: Proof veriﬁcation and the hardness of approximation problems. J. ACM 45(3), 501–555 (1998)
3. Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.P.: Short PCPS veriﬁable in polylogarithmic time. In: 20th Annual IEEE Conference on Compu- tational Complexity (CCC 2005), 11–15 June 2005, San Jose,  IEEE Computer Society (2005)
4. Bodlaender, H.L., Downey, R.G., Fellows, M.R., Hermelin, D.: On problems with- out polynomial kernels. J. Comput. Syst. Sci. 75(8), 423–434 (2009). https://doi. org/10.1016/j.jcss.2009.04.001
6. Chen, L., Goldwasser, S., Lyu, K., Rothblum, G.N., Rubinstein, A.: Fine-grained complexity meets IP = PSPACE. In: Chan, T.M. (ed.) Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2019, San Diego, 6–9 January 2019,  SIAM (2019)
8. Choudhuri, A.R., Jain, A., Jin, Z.: Snargs for P from LWE. In: 62nd IEEE Annual Symposium on Foundations of Computer Science, FOCS 2021, Denver, 7–10 Febru- ary 2022,  IEEE (2021) 374 S. Ben-David
9. Drucker, A.: New limits to classical and quantum instance compression. SIAM J. Comput. 44(5), 1443–1479 (2015)
10. Fortnow, L., Santhanam, R.: Infeasibility of instance compression and succinct PCPs for NP. In: Dwork, C. (ed.) Proceedings of the 40th Annual ACM Symposium on Theory of Computing, Victoria, 17–20 May 2008,  ACM (2008)
12. Jawale, R., Kalai, Y.T., Khurana, D., Zhang, R.Y.: Snargs for bounded depth computations and PPAD hardness from sub-exponential LWE. In: Khuller, S., Williams, V.V. (eds.) STOC 2021,  ACM (2021)
14. Kalai, Y.T., Paneth, O., Yang, L.: How to delegate computations publicly. In: Charikar, M., Cohen, E. (eds.) Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, 23–26 June 2019,  ACM (2019)
6. Our benchmark shows that multi-threaded HyperPlonk outperforms Jellyﬁsh starting from 214 constraints; the advantage grows when circuit size increases. This is mainly because FFTs scale worse than multi-exponentiations. HyperPlonk also has slightly better performance than Spartan. The diﬀerence is more pro- nounced in the multi-threaded benchmark which is likely because the Ark-Spartan implementation does not take full advantage of parallelism. We stress again that plonk+ is more expressive than RR1CS, and thus a fair comparison should be over the same application rather than the same size of constraints. Table 4 shows that HyperPlonk is 5 ∼60x faster than Spartan in those applications. 7 Orion+: a linear-time multilinear PCS with constant proof size Recently, Xie et al.
1. V sends a random vector r ∈Fk.
2. P sends vector yr, y0 ∈Fm where yr = k X i=1 ri · w[i, :], and y0 = k X i=1 t0,i · w[i, :] , where w ∈Fk×m is the message matrix being encoded and committed.
3. V sends P a random subset I ⊆[M] with size |I| = Θ(λ).
4. P opens the entire columns {W[:, j]}j∈I using Merkle proofs, where W ∈Fk×M is the row- wise encoded matrix. That is, P outputs the column commitment hj for every column j ∈I, and provide the Merkle proof for hj w.r.t. to Merkle root Cf.
5. V checks that (i) the Merkle openings are correct w.r.t. Cf, and (ii) for all j ∈I, it holds that E(yr)j = ⟨r, W[:, j]⟩and E(y0)j = ⟨t0, W[:, j]⟩.
6. V checks that ⟨y0, t1⟩= y. Note that by sampling a subset I with size Θ(λ) and checking that r·W, t0 ·W are consistent with the encodings E(yr), E(y0) on set I, the veriﬁer is conﬁdent that r · W, t0 · W are indeed close to the encodings E(yr), E(y0) with high probability. By setting k = √n, the prover takes O(n) F-ops and hashes; the veriﬁer time and proof size are both Oλ(√n). Orion describes an elegant code-switching scheme that reduces the proof size and veriﬁer time down to Oλ(log2(n)). However, the concrete proof size is still large. Next, we describe a scheme that has much smaller proof. Linear-time PCS with small proofs. Similar to Orion (and more generally, the proof com- position technique [21, 22, 50]), instead of letting the veriﬁer check the correctness of yr, y0 and the openings of the columns W[:, j]∀j ∈I, the prover can compute another (succinct) outer proof validating the correctness of yr, y0, W[:, j]. However, we need to minimize the outer proof’s circuit complexity, which is non-trivial. Orion builds an eﬃcient SNARK circuit that removes all of the 45 hashing gadgets, with the tradeoﬀof larger proof size. We describe a variant of their scheme that minimizes the proof size without signiﬁcantly increasing the circuit complexity. Speciﬁcally, after receiving challenge vector r ∈Fk, P instead sends V commitments Cr, C0 to the messages yr, y0; after receiving V’s random subset I ⊂[M], P computes a SNARK proof for the following statement: Statement 1 (PCS Eval veriﬁcation): • Witness: yr, y0 ∈Fm, {W[:, j]}j∈I. • Circuit statements: – Cr, C0 are the commitments to yr, y0 respectively. – For all j ∈I, it holds that ∗hj = H(W[:, j]) where H is a fast hashing scheme; ∗E(yr)j = ⟨r, W[:, j]⟩and E(y0)j = ⟨t0, W[:, j]⟩. – ⟨y0, t1⟩= y. • Public output: {hj}j∈I, and Cr, C0. Besides the SNARK proof, the prover also provides the openings of {hj}j∈I with respect to the commitments Cf. Intuitively, the new protocol is “equivalent” to Protocol 1, because the SNARK witness {W[:, j]}j∈I and yr, y0 are identical to those committed in Cf, Cr, C0 by the binding prop- erty of the commitments; and the SNARK does all of the veriﬁer checks. Unfortunately, the scheme has the following drawbacks: • Instantiating the commitments with Merkle trees leads to a large overhead on the proof size. In particular, the proof contains |I| Merkle proofs, each with length O(log n). For 128-bit security, we need to set |I| = 1568, and the proof size is at least 1 MBs for µ = 20. • The random subset I varies for diﬀerent evaluation instances. It is non-trivial to eﬃciently lookup the witness {E(yr)j, E(y0)j}j∈I in the circuit if the set I is dynamic (i.e. we need an eﬃcient random access gadget). • The circuit complexity is huge. In particular, the circuit is dominated by the commitments to yr, y0 and the hash commitments to {W[:, j]}j∈I. This leads to 2m + k|I| hash gadgets in the circuit. Note that we can’t use algebraic hash functions like Rescue
[1] or Poseidon [51], which are circuit-friendly, but have slow running times. For µ = 26, k = m = √n and 128-bit security (where |I| = 1568), this leads to 13 million hash gadgets where each hash takes hundreds to thousands of constraints, which is unaﬀordable. We resolve the above issues via the following observations. First, a large portion of the multilinear PCS evaluation proof is Merkle opening paths. We can shrink the proof size by replacing Merkle trees with multilinear PCS that enable eﬃcient batch openings (Section 3.8). Speciﬁcally, in the committing phase, after computing the hashes of W’s columns, instead of building another Merkle tree T of size M = O(n/k) and set the Merkle root as the commitment, the prover can commit to the column hashes using a multilinear PCS (e.g. KZG). Though the KZG committing is more expensive, the problem size has been reduced to O(n/k), thus for suﬃciently large k, the committing complexity is still approximately O(n) F-ops. A great advantage is that the batch opening proof for {hj}j∈I consists of only O(log n) group/ﬁeld elements, with good constant. Even better, when instantiating the outer proof with HyperPlonk(+), 46 the openings can be batched with those in the outer SNARK and thus incur almost no extra cost in proof size. Second, with Plookup, we can eﬃciently simulate random access in arrays in the SNARK circuit. For example, to extract witness {Yr,j = E(yr)j}j∈I, we can build an (online) table T where each element of the table is a pair (i, E(yr)i) (1 ≤i ≤M). Then for every j ∈I, we build a lookup gate checking that (j, Yr,j) is in the table T, thus guarantee that Yr,j is identical to E(yr)j. The circuit description is now independent of the random set I and we only need to preprocess the circuit once in the setup phase. Third, with the help of Commit-and-Prove-SNARKs (CP-SNARK) [31, 32, 3], there is no need to check the consistency between commitments Cr, C0 and yr, y0 in the circuit. Instead, we can commit (yr, y0) to a multilinear commitment C, and build a CP-SNARK proof showing that the vector underlying C is identical to the witness vector (yr, y0) in the circuit. We further observe that C can be a part of the witness polynomials, which further removes the need of an additional CP-SNARK proof. After applying previous optimizations, the proof size is dominated by the |I| ﬁeld elements {hj}j∈I. We can altogether remove them by applying the CP-SNARK trick again. In particular, since {hj}j∈I are both committed in the polynomial commitment Cf and the SNARK witness commitment, it is suﬃcient to construct a CP-SNARK proving that they are consistent in the two commitments with respect to set I. We refer to Section 3.8 for constructing CP-SNARK proofs from multilinear commitments. Since the bulk of veriﬁcation work is delegated to the prover, there is no need to set k = √n. Instead, we can set an appropriate k = Θ(λ/ log n) to minimize the outer circuit size. In particular, the circuit is dominated by 2 linear encodings (of length n/k) and |I| hashes (of length k). If we use vanilla HyperPlonk+ as the outer SNARK scheme and use Reinforced Concrete
[7] as the hashing scheme that has a similar running time to SHA-256, for µ = 30, k = 64 and 128-bit security (where |I| = 1568), the circuit complexity is only ≈226 constraints. And we can expect the running time of the outer proof to be Oλ(n). The resulting multilinear polynomial commitment scheme is shown in Figure 7. Remark 7.1 (CP-SNARKs instantiation.). We can use the algorithm in Section 3.8.1 to instanti- ate the CP-SNARK in Figure 7 from any multilinear PIOP-based SNARKs with minimal overhead. First, we can split the witness polynomial into two parts: one includes the vector (yr, y0) while the other includes the rest. The witness polynomial commitment to (yr, y0) is essentially the commit- ment Cpy in Figure 7, so that we don’t need to additionally commit to (yr, y0) and provide a proof. We emphasize that Cpy is sent before the prover receives the challenge set I, which is essential for knowledge soundness. Second, the CP-proof generation between the multilinear commitment Cf and the SNARK wit- ness polynomial commitment (w.r.t. set I) consists of a sumcheck with O(log m) rounds and 2 PCS openings (one for Cf and one for the witness polynomial). If we instantiate the SNARK with HyperPlonk+, we can batch the proving of the CP-proof and the SNARK proof so that the CP-proof adds no extra cost to the proof size beyond the original SNARK proof. 47 Building blocks: A CP-SNARK scheme OSNARK; an (extractable) polynomial commitment scheme PC; a hash commitment scheme HCom; and a linear encoding scheme E with minimum distance δ. Setup(1λ, µ∗) →gp: Given security parameter λ, upper bound µ∗on the number of variables, set m∗so that the running time of OSNARK (and PC) is Oλ(2µ∗) for circuit size (and degree) m∗. Run gpo ←OSNARK.Setup(1λ, m∗), gppc ←PC.Setup(1λ, m∗), run the indexing phase of OSNARK for the circuit statement in Figure 8 and obtain (vpo, ppo). Output gp := (gpo, gppc, vpo, ppo). Commit(gp; f) →Cf: Given polynomial f ∈F(≤1) µ with coeﬃcients w = (f⟨0⟩, . . . , f⟨n−1⟩), set m = n/k so that the running time of OSNARK (and PC) is Oλ(2µ) for circuit size (and degree) m. Interpret w as a k × m matrix (i.e. w ∈Fk×m): • Compute matrix W ∈Fk×M such that W[i, :] = E(w[i, :])∀i ∈[k]. Here E : Fm →FM is the linear encoding. • For each column j ∈[M], compute hash commitment hj ←HCom(W[:, j]), where W[:, j] ∈ Fk is the j-th column of W. • Let ph be the polynomial that interpolates vector (hj)j∈[M]. Output commitment Cf ← PC.Commit(gppc, ph). Open(gp, Cf, f): Given polynomial f ∈F(≤1) µ with coeﬃcients w ∈Fk×m, run the committing algorithm and check if the output is consistent with Cf. Eval(gp; Cf, z, y; f): Given public parameter gp, point z ∈Fµ and commitment Cf to polynomial f ∈F(≤1) µ with coeﬃcients w ∈Fk×m, transform z to vectors t0 ∈Fk and t1 ∈Fm as in Equation (15) such that f(z) = ⟨w, t0 ⊗t1⟩. The prover P and the veriﬁer V run the following protocol:
1. V sends P a random vector r ∈Fk.
2. Deﬁne vectors yr = k X i=1 ri · w[i, :], y0 = k X i=1 t0,i · w[i, :] . Let pr be the polynomial that interpolates (yr, y0). P sends V commitment Cpy ← PC.Commit(gppc, py).
3. V sends a random subset I ⊆[M] with size t := −λ log(1−δ).
4. P sends V, a CP-SNARK proof πo showing that • the statement in Figure 8 holds true; • the SNARK witness (yr, y0) is identical to the vector committed in Cpy; • the SNARK witness (hj)j∈I is consistent with that in the polynomial commitment Cf w.r.t. set I.
5. V checks πo with public input (α, r, y, z), and commitments Cpy, Cf. Figure 7: The multilinear polynomial commitment scheme. 48 Witness: • messages yr, y0 ∈Fm, encodings Yr, Y0 ∈FM, and evaluation vectors t0 ∈Fk, t1 ∈Fm; • the columns of W in subset I, that is, W ′ = (W[:, j])j∈I ∈Fk×|I|; • the values of Yr, Y0 in subset I, that is Y′ r = (Yr,j)j∈I ∈F|I|, and Y′ 0 = (Y0,j)j∈I ∈F|I|; • column hashes h = (h1, . . . , h|I|) ∈F|I|. Public input: • challenge vector r ∈Fk; • random subset I ⊆[M]; • evaluation point z ∈Fµ and claimed evaluation y ∈F. Circuit statements: • t0, t1 is the correct transformation from z as in Equation (15). • Yr = E(yr) and Y0 = E(y0). • For i = 1 . . . |I|, let ji ∈I be the i-th element in I, it holds that – Y′ r,i = Yr,ji, that is, (ji, Y′ r,i) is in the table {(k, Yr,k)}k∈[M], and – Y′ 0,i = Y0,ji, that is, (ji, Y′ 0,i) is in the table {(k, Y0,k)}k∈[M]. • For i = 1 . . . |I|, it holds that – hi = HCom(W ′[:, i]) where HCom : Fk →F is the hash commitment scheme; – Y′ r,i = ⟨r, W ′[:, i]⟩and Y′ 0,i = ⟨t0, W ′[:, i]⟩. • ⟨y0, t1⟩= y. Figure 8: The outer SNARK circuit statement. The circuit conﬁguration is independent of the random set I. Theorem 7.1. The multilinear polynomial commitment scheme in Figure 7 is correct and binding. The PCS evaluation protocol is knowledge-sound. Proof. Correctness and binding. Correctness holds obviously by inspection of the protocol. We prove the binding property by contradiction. Suppose an adversary ﬁnds a commitment Cf and two polynomials f1, f2 with diﬀerent coeﬃcients w1, w2 ∈Fk×m such that Cf can open to both w1 and w2. There are two cases:
1. Cf can open to two diﬀerent vectors of column hash commitments h1, h2 ∈FM, which contradicts the binding property of the PCS PC.
2. Cf binds to a single vector h ∈FM, but encoding w1, w2 lead to two diﬀerent encoded matrices W1, W2 ∈Fk×M. This contradicts the collision resistance of the hash function. In summary, the binding property holds. Knowledge soundness. We use a similar technique as in
[50] that enables extracting polynomials even if the linear code E is not eﬃciently decodable. For any adversary A that can pass the PCS evaluation check with probability more than ϵ, the extractor EA works as follows:
1. Run A and obtain commitment Cf, point z ∈Fµ, and evaluation y ∈F. Run the extractors of the PCS and the hash function to recover the matrix W ′ ∈Fk×M underlying Cf. Abort if the extraction fails. 49
2. Set S ←∅, repeat the following procedures until |S| ≥k or the number of r being sampled is more than 8k/ϵ: • Sample and send A a random vector r ← $ Fk. • Obtain the PCS commitments Cpy. Use the PCS extractor to extract the vector (yr, y0) ∈ F2m. Abort and rerun with another r if the extraction fails. • Sample and send A a random subset I ⊆[M]. • Obtain the CP-SNARK proof πo. Add the pair (r, yr) into set S if the proof correctly veriﬁes.
1. This is critical for building a lookup protocol. In some versions of the Halo 2 arithmetization, the proof system accesses machine states from more than the previous step. To implement this, we need higher degree shifts. This can be done by composing the next function multiple times, but this has an exponential blow-up in veriﬁer time. Implementing higher degree next functions eﬃciently remains an open problem. • Better codes and hash functions for Orion+: The utility of Orion+ for smaller polynomials is limited by the use of recursion. Only for large multilinear polynomials (approximately with more than 24 variables), does the recursive circuit size become less than the original polynomial size. The keys to improving this are linear codes with better distance and more eﬃcient and circuit-friendly hash functions. • Automatic custom gate design: HyperPlonk+ supports high-degree custom gates eﬃciently. Currently, designing suitable custom gates for speciﬁc applications is a task left to the circuit designer. It remains an open problem to have a more principled approach that automates and optimizes the design of the custom gates for any given application. • Linear-time permutation argument for small ﬁelds: In Section 3.6 we present a permutation argument with good soundness even for non-exponential ﬁelds. The argument unfortunately only has quasi-linear prover time. An important open question is whether there exists a permutation argument or a multi-set argument with linear prover time and optimal soundness. Acknowledgments. We want to thank Ben Fisch and Alex Oezdemir for helpful discussions and Tiancheng Xie for answering many questions regarding Orion and Virgo. We want to thank Alessandro Chiesa for bringing the permutation check soundness question as well a connection to PCPs to our attention. Finally, we thank Srinath Setty for suggesting improvements to our evaluation section. This work was partially funded by NSF, DARPA, the Simons Foundation, UBRI, and NTT Research. Opinions, ﬁndings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reﬂect the views of DARPA. References
[4] arkworks contributors. arkworks zksnark ecosystem, 2022.
[6] L. Babai and S. Moran. Arthur-merlin games: A randomized proof system, and a hierarchy of complexity classes. J. Comput. Syst. Sci., 36(2):254–276, 1988.
[11] E. Ben-Sasson, D. Carmon, S. Kopparty, and D. Levit. Elliptic curve fast fourier transform (ecﬀt) part ii: Scalable and transparent proofs over all large ﬁelds. 2022.
[15] E. Ben-Sasson and M. Sudan. Short pcps with polylog query complexity. SIAM Journal on Computing, 38(2):551–607, 2008.
[16] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In S. Goldwasser, editor, ITCS 2012, pages 326–349. ACM, Jan. 2012. 53
[33] J. L. Carter and M. N. Wegman. Universal classes of hash functions. In Proceedings of the ninth annual ACM symposium on Theory of computing, pages 106–112, 1977.
[37] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In A. C.-C. Yao, editor, ICS 2010, pages 310–331. Tsinghua University Press, Jan. 2010.
[40] H. de Valence. Merlin transcript, 2022.
[41] J. Drake. Plonk-style SNARKs without FFTs. link, 2019.
[42] EspressoSystems. Speciﬁcations: Conﬁgurable asset privacy. Github, 2022.
[43] A. Gabizon. Multiset checks in plonk and plookup. https://hackmd.io/@arielg/ByFgSDA7D. 55
[45] A. Gabizon and Z. J. Williamson. Proposal: The turbo-plonk program syntax for specify- ing snark programs. https://docs.zkproof.org/pages/standards/accepted-workshop3/ proposal-turbo_plonk.pdf, 2020.
[48] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsiﬁable assumptions. In L. Fortnow and S. P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press, June 2011.
[49] S. Goldwasser, S. Micali, and C. Rackoﬀ. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.
[54] D. Harvey and J. Van Der Hoeven. Polynomial multiplication over ﬁnite ﬁelds in time. Journal of the ACM (JACM), 69(2):1–40, 2022.
[55] D. Hopwood, S. Bowe, T. Hornby, and N. Wilcox. Zcash protocol speciﬁcation. version 2022.3.8. Online, 2022. https://zips.z.cash/protocol/protocol.pdf.
[58] J. Kilian. A note on eﬃcient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.
[61] C. Lund, L. Fortnow, H. Karloﬀ, and N. Nisan. Algebraic methods for interactive proof systems. Journal of the ACM (JACM), 39(4):859–868, 1992.
[64] S. Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, Nov. 1994.
[73] J. Thaler. Proofs, arguments, and zero-knowledge, 2020.
[77] M. N. Wegman and J. L. Carter. New hash functions and their use in authentication and set equality. Journal of computer and system sciences, 22(3):265–279, 1981.
[80] T. Xie, Y. Zhang, and D. Song. Orion: Zero knowledge proof with linear prover time. Cryp- tology ePrint Archive, Report 2022/1010, 2022. https://eprint.iacr.org/2022/1010.
[83] Zcash. PLONKish arithmetization. link, 2022.
[35] and deﬁne the (honest veriﬁer) zero-knowledge property of PIOPs. Since the provers in sumcheck PIOPs also send ﬁeld elements, we slightly adapt the deﬁnition in [35]. Deﬁnition A.1. A PIOP ⟨P, V⟩has perfect zero-knowledge with query bound t and query checker C if there is a PPT simulator S such that for every ﬁeld F, index i, instance x, witness w, and every (t, C)-admissable veriﬁer V∗, the following transcripts are identically distributed: View (P(F, i; x; w), V∗) ≈SV∗(F, i; x) . Here the view consists of V∗’s randomness, the non-oracle messages sent by P, and the list of answers to V∗’s oracle queries. A veriﬁer is (t, C)-admissible if it makes no more than t queries, and each query is accepted by the checker C. We say that ⟨P, V⟩is honest-veriﬁer-zero-knowlege (HVZK) if there is a simulator for V. A.2 Polynomial masking Deﬁnition A.2. A randomized algorithm msk is a (t, C, µ)-masking if
1. for every d ∈N and every polynomial f ∈F(≤d) µ , the masked polynomial f∗← $ msk(f, t, C) does not change evaluations over the boolean hypercube Bµ;
2. for every d ∈N and every polynomials f ∈F(≤d) µ , and every list of queries q := (q1, . . . , qt) that is accepted by the checker C, let f∗← $ msk(f, t, C). It holds that f∗(q1), . . . , f∗(qt)  is uniformly distributed over Ft. 59 Lemma A.1. There is a (t, Cℓ, µ)-masking algorithm msk(f, t, ℓ) for every µ, t ∈N and ℓ∈[µ], where checker Cℓaccepts a list of queries (q1, . . . , qt) if and only if bi,ℓ/∈{0, 1, b1,ℓ, . . . , bi−1,ℓ} for every query qi := (bi,1, . . . , bi,µ) ∈Fµ (1 ≤i ≤t). For any f ∈F(≤d) µ and ℓ∈[µ], the degree of the masked polynomial f∗←msk(f, t, ℓ) is max(d, t + 1). Proof. Given a polynomial f ∈F(≤d) µ , query bound t, and checker Cℓ, the algorithm does follow: • Sample a univariate polynomial R(X) := c0 + c1X + . . . ct−1Xt−1 where c0, . . . , ct−1 ← $ F. • Output f∗:= f + Z(Xℓ) · R(Xℓ), where Z(Xℓ) := Xℓ· (1 −Xℓ). It is clear that f∗has degree max(d, t + 1); f∗does not change f’s evaluations over Bµ as Z evaluates to zero over Bµ. Next, we argue that f∗:= f∗(q1), . . . , f∗(qt)  ∈Ft is uniformly random. Denote query qi := (bi,1, . . . , bi,µ) (1 ≤i ≤t), we deﬁne R to be R := Z(b1,ℓ) · R(b1,ℓ), . . . , Z(bt,ℓ) · R(bt,ℓ)  . Since the queries satisfy bi,ℓ/∈{0, 1} for every i ∈[t], it holds that zi := Z(bi,ℓ) are non-zero and thus invertible. Moreover, since R is a random univariate polynomial with degree t −1 and {b1,ℓ, . . . , bt,ℓ} are distinct, it holds that {R(b1,ℓ), . . . , R(bt,ℓ)} are uniformly random. Therefore R is uniformly random, and thus f∗= f + q is also uniformly random where f := f(q1), . . . , f(qt)  . A.3 Zero knowledge SumCheck Construction. Xie et al.
[79] described an eﬃcient ZK compiler for sumchecks. For reader’s convenience, we adapt Construction 1 in
[79] to a PIOP. Zero knowledge SumCheck PIOP ⟨P, V⟩: • Input: polynomial f ∈F(≤d) µ and claimed sum H ∈F. • P samples a polynomial g := c0 +g1(x1)+· · ·+gµ(xµ) where gi(xi) := ci,1xi +· · ·+ci,dxd i and ci,1, . . . , ci,d are uniformly random. P sends oracle g and a claimed sum G := P x∈Bµ g(x). • V sends a challenge ρ ← $ F∗. • P and V run SumCheck PIOP (Section 3.1) over polynomial f +ρg and claimed sum H +ρG. • V queries g and f at point r where r ∈Fµ is the vector of sumcheck’s challenges. V then checks that f(r) + ρg(r) is consistent with the last message of the sumcheck. The completeness of the ZK PIOP holds obviously, it was shown in
[34] that the PIOP also preserves soundness. The zero knowledge property is proved in
[79] and we state it below. Lemma A.2 (Theorem 3 of [79]). For every ﬁeld F, veriﬁer V∗and multivariate polynomial f ∈ F(≤d) µ , there is a simulator Ssum(F, µ, d, H) that perfectly simulates P’s oracle answers except for f(r). Here H := P x∈Bµ f(x). 60 A.4 Zero knowledge compilation for SumCheck-based PIOPs A general description to the sumcheck-based PIOPs. The multivariate PIOPs considered in this paper can all be adapted to the following format. General sumcheck-based PIOPs:
1. Both P and V have oracle access to a public multilinear polynomial p0 ∈F(≤1) µ0 .
2. For every i ∈[k1], P sends a multilinear polynomial pi ∈F(≤1) µi , and V sends some random challenges. pi is a function of p0, . . . , pi−1 and veriﬁer’s previous challenges.
3. P and V sequentially run k2 sumcheck PIOPs. The i-th (1 ≤i ≤k2) sumcheck is over a polynomial fi := hi(g1, . . . , gci) ∈F(≤di) νi , where hi is public information and each multilinear polynomial gj ∈F(≤1) νi (1 ≤j ≤ci) is gj := v|XS=b for some boolean vector b and some v ∈{p1, . . . , pk1}, that is, gj is a partial polynomial of v where the variables in S are set to b.
4. For every i ∈[k2], V queries a random point ri ∈Fνi to the oracle fi, where ri are the round challenges in the i-th sumcheck. V then checks that fi(ri) is consistent with the last message in the i-th sumcheck.
1. For every i ∈[k1], ˆP sends an oracle [[p∗ i ]] where p∗ i ← $ msk(pi, ti, ℓi). ˆV sends the same challenges as V does. 61
2. ˆP and ˆV sequentially run k2 zero knowledge sumcheck PIOPs (Section A.3). The i-th (1 ≤ i ≤k2) sumcheck is over the polynomial f∗ i := hi(g∗ 1, . . . , g∗ ci) ∈F(≤dit∗) νi , where hi is the same as in ⟨P, V⟩; each g∗ j ∈F(≤t∗) νi (1 ≤j ≤ci) is g∗ j := v∗ |XS=b for some boolean vector b and some v∗∈{p∗ 1, . . . , p∗ k1}.
3. For every i ∈[k2], ˆV queries a random point ri ∈Fνi to the oracle fi, where ri are the round challenges in the i-th ZK sumcheck. ˆV then checks that fi(ri) is consistent with the last message of the i-th ZK sumcheck. We emphasize a slight modiﬁcation over the original PIOP ⟨P, V⟩: in the i-th sumcheck, ˆV samples each round challenge ri,j (1 ≤j ≤µi) in the set F \ {0, 1, r1,j, . . . , ri−1,j} rather than in F.
4. ˆV simulates V, i.e., for all i ∈[k3], queries points ci to oracle p∗ ji and checks the evaluation. Theorem A.3. Given any PIOP ⟨P, V⟩for some relation over the boolean hypercube, the compiled PIOP ⟨ˆP, ˆV⟩is HVZK. Moreover, ⟨ˆP, ˆV⟩preserves perfect completeness and negligible soundness. Proof. Completeness. Completeness holds because the sumcheck relations are over boolean hy- percubes and the masked polynomials’ evaluations do not change over the boolean hypercubes by the property of msk. Soundness. Compared to the sumchecks in ⟨P, V⟩, the following changes of the sumchecks in ⟨ˆP, ˆV⟩aﬀect soundness error:
1. The degrees of the sumcheck polynomials are increased by a factor t∗.
2. The challenge space of j-th round in the i-th (1 ≤i ≤k2) sumcheck is F\{0, 1, r1,j, . . . , ri−1,j} rather than F.
3. The sumcheck protocols are replaced with ZK sumchecks. Since t∗and k2 are constants and ZK sumchecks preserves soundness [34], the compiled protocol preserves negligible soundness. HVZK. We describe the simulator as follows. The simulator S ˆV(F, i; x):
1. Honestly generate the public polynomial p0 ∈F(≤1) µ0 .
2. Pick arbitrary polynomial {˜pi}i∈[k1] conditioned on that the sumcheck relations over f1, . . . , fk2 hold. Send ˆV polynomials {˜p∗ i }i∈[k1] where ˜p∗ i ← $ msk(˜pi, ti, ℓi), obtain from ˆV the challenges in the ﬁrst k1 rounds.
3. Run the next k2 ZK sumcheck PIOPs using p0 and the sampled polynomials {˜p∗ i }i∈[k1].
4. For every i ∈[k2], answer query f∗ i (ri) honestly using {˜p∗ i }i∈[k1].
1. It is shown in Theorem 10 of
[19] that every additive and m-spanning PCS can be compiled into a hiding PCS with a zero-knowledge Eval protocol, where m-spanning means that commitments to polynomials of degree at most m can already generate the commitment space G. Thus we can construct a hiding PCS for f∗with ZK evaluations from any additive and spanning polynomial commitment schemes (e.g., KZG and FRI). In particular, one instantiation is to set the commitment of f∗to be (C1, C2) ∈G where C1 is the multilinear commitment to f and C2 is the univariate commitment to Z(X) · R(X), then apply the ZK transformation in [19]. By combining Theorem 2.4 and Theorem A.3 we obtain the following corollary. Corollary A.4. Given any (non-hiding) additive and spanning polynomial commitment schemes, we can transform any (non-ZK) sumcheck-based PIOP (Section A.4) for relation R to a zk-SNARK for R. B The FRI-based multilinear polynomial commitment In this Section, we construct a simple multilinear polynomial commitment scheme (PCS) from FRI [9]. Along the way, we also show how to generically transform a univariate PCS to a multilinear PCS using the tensor-product univariate PIOP from [24], which might be of independent interest. We note that Virgo [84, §3] describes another scheme constructing multilinear PCS from FRI. The main idea is to build the evaluation opening proof from a univariate sumcheck [12], which in turn uses FRI. However, the naive scheme incurs linear-time overhead for the veriﬁer. Virgo [84, §3] resolves the issue by delegating the veriﬁer computation to the prover. To this end, the prover needs to compute another GKR proof convincing that the linear-time veriﬁer will accept the proof. This complicates the scheme and adds additional concrete overhead on prover time and proof size. 63 We refer to [9, 57] and
[53] for background of FRI low-degree testing and the approach to build univariate PCS from FRI. We note that the FRI-based univariate PCS supports batch opening. The evaluation opening protocol for multiple points on multiple polynomials invokes only a single call to the FRI protocol. Below we present a generic approach to transforming any univariate PCS into a multilinear PCS. Generic transformation from univariate PCS to multilinear PCS. Bootle et al. built a univariate PIOP for the tensor-product relation in Section 5 of [24]. The tensor-product relation (x, w) = (F, n, z1, . . . , zµ, y), f  states that f ∈Fn satisﬁes that ⟨f, ⊗j(1, zj)⟩= y, where ⟨·, ·⟩ denotes an inner product, and ⊗denotes a tensor product. The PIOP naturally implies an algorithm that transforms univariate polynomial commitment schemes to multilinear polynomial commitment schemes. • The commitment to a multilinear polynomial ˜f with monomial coeﬃcients, f is the commit- ment to a univariate polynomial f with the same coeﬃcients. • To open ˜f at point (z1, . . . , zµ) that evaluates y, the prover and the veriﬁer runs the univariate PIOP for the relation (x, w) = (F, n, z1, . . . , zµ, y), f  , which reduces to a batch evaluation on a set of µ + 1 univariate polynomials. We provide the concrete construction below. Let PCu = (Setup, Commit, BatchOpen, BatchVfy) be a univariate PCS, we construct a multilinear PCS PCm as follows. • PCm.Setup(1λ, µ) →(ck, vk). On input security parameter λ and the number of variables µ, output PCu.Setup(1λ, n) where n = 2µ. • PCm.Commit(ck, ˜f) →c. On input committer key ck, multilinear polynomial ˜f with coeﬃ- cients f ∈Fn, output PCu.Commit(ck, f) where f has the same coeﬃcients as f. • PCm.Open(ck, ˜f, z, y) →π. On input committer key ck, multilinear polynomial ˜f, point z ∈Fµ and evaluation y ∈F, the prover computes the proof as follows. Let f0(X) := f(X) be the committed univariate polynomial that has the same coeﬃcients as ˜f, consider the following PIOP for the tensor-product relation (x, w) = (F, n, z, y), f  : – The prover sends the veriﬁer univariate polynomials f1, . . . , fµ such that for all i ∈[µ], fi(X) = gi−1(X) + zi · hi−1(X) , where gi−1, hi−1 satisﬁes that fi−1(X) = gi−1(X2) + X · hi−1(X2). – The veriﬁer samples a random challenge β ←$ F× (where F× is a multiplicative subgroup of F), and queries the oracles to obtain evaluations {ai, bi, ci}i∈{0,...,µ} such that ai := fi(β), bi := fi(−β), ci := fi+1(β2) . Note that we skip fµ+1(β2) and set cµ := y. – The veriﬁer checks that for all i ∈{0, . . . , µ}, ci = ai + bi 2 + zi · ai −bi 2β . 64 The opening proof π comprises (i) the univariate commitments to f1, . . . , fµ, (ii) the evalua- tions {ai, bi, ci}i∈{0,...,µ}, and (iii) the batch opening proof for polynomials (f0, f1, . . . , fµ) at points (β, −β, β2), where the random challenge β is derived via the Fiat-Shamir transform. • PCm.Vfy(vk, c, z, y, π) ∈{0, 1}. On input veriﬁer key vk, commitment c, point z, evaluation y, and proof π, parse π to commitments (c1, . . . , cµ), evaluations evals, and the batch opening proof π∗. Derive random challenge β via the Fiat-Shamir transform, perform the veriﬁcation check in the above PIOP, and run PCu.BatchVfy(vk, (c, c1, . . . , cµ), (β, −β, β2), evals, π∗). Eﬃciency. We emphasize that when instantiated PCu with the FRI-based PCS, the multilinear polynomial commitment scheme has approximately the same complexity as that in the univariate setting. In particular, the committing phase takes only a Merkle root computation with tree depth log(n); the opening phase takes (i) µ Merkle commitment computation where the i-th (1 ≤i ≤µ) Merkle tree is with size 2µ−i, and (ii) a univariate PCS batch evaluation protocol that is simply a single call to the FRI protocol. C Unrolled and optimized Hyperplonk In Figure 9 and Figure 10, we present an optimized and batched version of HyperPlonk. The protocol batches the zerochecks and additionally batches all evaluations using RBATCH. Moreover, the sumcheck has complexity proportional to 2µ rather than 2µ+νw where νw is the logarithm of the number of wires. Proof size analysis of the compiled protocol. We analyze the concrete proof size of the opti- mized PIOP. We analyze the proof size after compilation, i.e., where the prover sends commitments and performs evaluation proofs. The prover sends
1. ℓw + 2 of µ-variate multilinear polynomial commitments (ℓw for the witness and 2 for the product polynomial),
2. µ of degree max(d−2, ℓw −1) univariate polynomial commitments and 2µ claimed evaluations (in the ﬁrst batched sumcheck),
3. 8 + 2 · ℓw + ℓq claimed multilinear evaluations,
4. 1 univariate evaluation of a batched univariate polynomial,
5. 1 multilinear evaluation of a batched multilinear polynomial, and
6. 2 · (µ + ⌈log2(8 + 2 · ℓw + ℓq)⌉) ﬁeld elements for the sumcheck in the PIOP of RBATCH. For KZG-based commitments, the proof size is 2 + ℓw + µ G1 elements and 4µ + 10 + 2 · ℓw + ℓq + 2⌈log2(8 + 2 · ℓw + ℓq)⌉ﬁeld elements. For the case where ℓw = ℓq = 3, using BLS12-381, where G1 elements are 48 bytes and ﬁeld elements are 32 bytes the proof size becomes 176 · µ + 1168 bytes. For µ = 20, this is only 4688 bytes. 65 Indexer. The indexer I on an input circuit C calls the permutation indexer Iperm(σ): ([[sid]], [[sσ]]) ← Iperm(σ) and computes the selector polynomial q ∈F(≤1) µ+νq. Let ℓw = 2νw be the number of wires, denote by Sσ := [[sσ(⟨0⟩νw, X)]], [[sσ(⟨1⟩νw, X)]], . . . , [[sσ(⟨ℓw −1⟩νw, X)]]  the lists of partial polynomials of sσ ∈F(≤1) µ+νw. The indexer outputs ([[q]], Sσ). We note that for all i ∈[0, 2µ+νw), sid ∈F(≤1) µ+νw evaluates to i at point ⟨i⟩µ+νw ∈Bµ+νw (where ⟨i⟩µ+νw denotes µ + νw-bit binary encoding of i). Since multilinear extension is unique, it holds that sid(X) = P i∈[µ+νw] 2i−1 · Xi and thus one can evaluate sid at any points in time O(µ + νw). Hence, there is no need for the indexer to output oracle [[sid]]. Figure 9: The indexer of the optimized PIOP for RPLONK. 66 P(gp, i, p, w) and V(gp, p, [[q]], Sσ) run the following protocol.
1. P sends V the witness oracles W := [[w0]], [[w1]], . . . , [[wℓw−1]]  where wi := w(⟨i⟩νw, X) is the ith (0 ≤i < ℓw) partial polynomial of the witness polynomial w ∈F(≤1) µ+νw.
2. V sends input challenge rIO ← $ Fν, R1 MSET challenge γ and R2 MSET challenges β.
3. P computes the product polynomial ˜v ∈F(≤1) µ+1 from W, Sσ, sid and the challenges β, γ (See Sec- tion 3.3), where for all x ∈Bµ, ˜v(0, x) = Y i∈[0,ℓw) Wi(x) + β · sid(⟨i⟩νw, x) + γ Wi(x) + βSσ,i(x) + γ . Here Wi, Sσ,i denotes the ith polynomial in W, Sσ respectively. P then sends oracles [[˜v(0, X)]], [[˜v(1, X)]] to V.
4. Veriﬁer sends challenges α1, α2 to batch three zerochecks, one resulting from the gate identity (see Section 4.2) and two from the productcheck (see Section 3.3). The two zerocheck virtual polynomials Q1(X) ∈F(≤2) µ , Q2(X) ∈F(≤ℓw+1) µ for the productcheck are Q1(X) := ˜v(1, X) −˜v(X, 0)˜v(X, 1) and Q2(X) := Y i∈[0,ℓw) (Wi(X) + β · sid(⟨i⟩νw, X) + γ) −˜v(0, X) Y i∈[0,ℓw) (Wi(X) + βSσ,i(X) + γ) . Note that ˜v(X, 0), ˜v(X, 1) can be simulated given the oracle accesses to [[˜v(0, X)]], [[˜v(1, X)]], be- cause for all b ∈{0, 1}, ˜v(X, b) = (1 −X1) · ˜v(0, X2, . . . , Xµ, b) + X1 · ˜v(1, X2, . . . , Xµ, b).
5. V send zerocheck challenge rZ ← $ Fµ
6. P and V run sumcheck resulting from batched zerocheck. The sumcheck is of size µ and has degree max(d + 1, ℓw + 2). In each round, the prover sends an oracle to the univariate round polynomial as well as the claimed evaluation. The veriﬁer delays querying the oracles. Similarly, in the last round, the veriﬁer receives the claimed evaluations of all the multilinear polynomials. There are 8 + 2 · ℓw + ℓq total evaluations: • 1 + ℓw of W (ℓw from the batched sumcheck, one to check the outputs) • 3 of ˜v(0, X) and 4 of ˜v(1, X) from the product check • ℓq of q (one per selector) • ℓw of Sσ from the product check (there is no need to query sid as V can eﬃciently evaluate it).
7. V uses the claimed evaluations to verify all previous protocols.
8. P and V run the univariate batch-opening algorithm from
[19] to reduce all the round polynomial queries to one.
9. P and V run RBATCH on all evaluations using a degree 2, µ+⌈log2(8+2·ℓw +ℓq)⌉round sum-check. In the protocol, the prover directly transmits the round polynomial using 2 ﬁeld elements. The veriﬁer can compute the third from the claimed sum. Figure 10: Optimized PIOP for RPLONK. 67
13. Lenstra, A.K., Lenstra, H.W., Lov´asz, L.: Factoring polynomials with rational coeﬃcients. Mathematische annalen 261(ARTICLE), 515–534 (1982) Key Recovery Attack on the Partial Vandermonde Knapsack Problem 225
15. Luzzi, L., Stehl´e, D., Ling, C.: Decoding by embedding: correct decoding radius and DMT optimality. IEEE Trans. Inf. Theory 59(5), 2960–2973 (2013). https:// doi.org/10.1109/TIT.2012.2236144
17. The FPLLL Development Team: FPLLL, a lattice reduction library, Version: 5.4.5 (2023). https://github.com/fplll/fplll
1. Aguilar-Melchor, C., Blazy, O., Deneuville, J.C., Gaborit, P., Z´emor, G.: Eﬃcient encryption from random quasi-cyclic codes. IEEE Trans. Inf. Theory 64(5), 3927– 3943 (2018). https://doi.org/10.1109/TIT.2018.2804444
8. Bardet, M., Faug`ere, J.C., Salvy, B., Spaenlehauer, P.J.: On the complexity of solving quadratic Boolean systems. J. Complex. 29(1), 53–75 (2013). https://doi. org/10.1016/j.jco.2012.07.001 420 P. Briaud and M. Øygarden
9. Bardet, M., Faug`ere, J.C., Salvy, B., Yang, B.Y.: Asymptotic behaviour of the index of regularity of quadratic semi-regular polynomial systems. In: Gianni, P. (ed.) The Eﬀective Methods in Algebraic Geometry Conference (MEGA 2005), (2005)
15. Bettale, L.: Cryptanalyse alg´ebrique : outils et applications. Ph.D. thesis, Univer- sit´e Pierre et Marie Curie - Paris 6 (2012)
25. Coppersmith, D.: Solving homogeneous linear equations over GF(2) via block wiedemann algorithm. Math. Comput. 62(205), 333–350 (1994). https://doi.org/ 10.2307/2153413
33. Le Gall, F.: Powers of tensors and fast matrix multiplication. In: Proceedings of the 39th International Symposium on Symbolic and Algebraic Computation,  (2014). https://doi.org/10.1145/2608628.2608664
38. Prange, E.: The use of information sets in decoding cyclic codes. IRE Trans. Inf. Theory 8(5), 5–9 (1962). https://doi.org/10.1109/TIT.1962.1057777
41. Thom´e, E.: Subquadratic computation of vector generating polynomials and improvement of the block wiedemann algorithm. J. Symb. Comput. 33(5), 757–775 (2002). https://doi.org/10.1006/jsco.2002.0533
43. Wiedemann, D.: Solving sparse linear equations over ﬁnite ﬁelds. IEEE Trans. Inf. Theory 32(1), 54–62 (1986). https://doi.org/10.1109/TIT.1986.1057137
2. Aoki, K., Sasaki, Y.: Preimage attacks on one-block MD4, 63-step MD5 and more. In: SAC 2008. vol. 5381,  Springer (2008). https://doi.org/10.1007/ 978-3-642-04159-4_7
4. Aumasson, J., Meier, W., Mendel, F.: Preimage attacks on 3-pass HAVAL and step-reduced MD5. In: SAC 2008. vol. 5381,  https://doi.org/10. 1007/978-3-642-04159-4_8
12. Bogdanov, A., Rechberger, C.: A 3-subset meet-in-the-middle attack: Cryptanaly- sis of the lightweight block cipher KTANTAN. In: SAC 2010. vol. 6544, Springer (2010). https://doi.org/10.1007/978-3-642-19574-7_16
30. Dunkelman, O., Sekar, G., Preneel, B.: Improved meet-in-the-middle attacks on reduced-round DES. In: INDOCRYPT 2007, Proceedings. vol. 4859, Springer (2007). https://doi.org/10.1007/978-3-540-77026-8_8
48. Liu, F., Isobe, T., Meier, W., Yang, Z.: Algebraic attacks on round-reduced Keccak. In: ACISP 2021, Proceedings. vol. 13083,  https://doi.org/10.1007/ 978-3-030-90567-5_5
49. Liu, G., Lu, J., Li, H., Tang, P., Qiu, W.: Preimage attacks against lightweight scheme xoodyak based on deep learning. In: Future of Information and Commu- nication Conference.  Springer (2021). https://doi.org/10.1007/ 978-3-030-73103-8_45
55. Rajasree, M.S.: Cryptanalysis of round-reduced Keccak using non-linear struc- tures. In: INDOCRYPT 2019. vol. 11898,  https://doi.org/10.1007/ 978-3-030-35423-7_9
56. Sasaki, Y.: Integer linear programming for three-subset meet-in-the-middle attacks: Application to GIFT. In: IWSEC 2018. vol. 11049,  https://doi.org/ 10.1007/978-3-319-97916-8_15
59. Sasaki, Y., Aoki, K.: Preimage attacks on 3, 4, and 5-pass HAVAL. In: ASI- ACRYPT 2008, Proceedings. vol. 5350,  Springer (2008). https: //doi.org/10.1007/978-3-540-89255-7_16
3. Bar-El, H., Choukri, H., Naccache, D., Tunstall, M., Whelan, C.: The sorcerer’s apprentice guide to fault attacks. Proc. IEEE 94(2), 370–382 (2006). https://doi. org/10.1109/JPROC.2005.862424 24 Marcel Nageler, Christoph Dobraunig, and Maria Eichlseder
9. Canetti, R., Lindell, Y., Ostrovsky, R., Sahai, A.: Universally composable two-party and multi-party secure computation. In: 34th ACM STOC. ACM Press, May 2002
14. Cleve, R.: Limits on the security of coin ﬂips when half the processors are faulty (extended abstract). In: 18th ACM STOC. ACM Press, May 1986
18. Fischlin, M., Janson, C., Mazaheri, S.: Backdoored hash functions: immunizing HMAC and HKDF. In: CSF 2018 Computer Security Foundations Symposium. IEEE Computer Society Press (2018)
20. Goldreich, O., Micali, S., Wigderson, A.: How to play any mental game or A completeness theorem for protocols with honest majority. In: 19th ACM STOC. ACM Press, May 1987
12. Dutta, A., Nandi, M., Saha, A.: Proof of mirror theory for ξmax =
2. IEEE Trans. Inf. Theory 68(9), 6218–6232 (2022). https://doi.org/10.1109/TIT.2022.3171178
13. Eberhard, S.: More on additive triples of bijections (2017). https://arxiv.org/abs/ 1704.02407
14. Eberhard, S., Manners, F., Mrazovi´c, R.: Additive triples of bijections, or the toroidal semiqueens problem. J. Eur. Math. Soc. 21(2), 441–463 (2018). https:// doi.org/10.4171/JEMS/841 62 I. Dinur
15. Gessel, I.M., Stanley, R.P.: Algebraic enumeration. In: Handbook of Combinatorics, vol. 2,  MIT Press, Cambridge (1996)
23. O’Donnell, R.: Analysis of Boolean Functions. Cambridge University Press, New York (2014)
25. Patarin, J.: Generic attacks for the XOR of K random permutations. IACR Cryp- tol. ePrint Arch. p. 9 (2008). http://eprint.iacr.org/2008/009
18. Daemen, J., Hoﬀert, S., Assche, G.V., Keer, R.V.: The design of Xoodoo and Xooﬀf. 2018, 1–38 (2018)
27. Holenstein, T., K¨unzler, R., Tessaro, S.: The equivalence of the random oracle model and the ideal cipher model, revisited. In: STOC 2011 (2011)
29. Jablon, D.P.: Extended password key exchange protocols immune to dictionary attacks. In: 6th IEEE International Workshops on Enabling Technologies: Infras- tructure for Collaborative Enterprises (WETICE 1997), , Cambridge, MA, USA, 18–20 June 1997. IEEE Computer Society (1997)
36. Marlinspike, M., Perrin, T.: The X3DH key agreement protocol (2016). https:// signal.org/docs/speciﬁcations/x3dh/
nathanielclizbe@MacBookAir citation-analysis % 
